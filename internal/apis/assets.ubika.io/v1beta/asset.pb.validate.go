// Code generated by protoc-gen-validate. DO NOT EDIT.
// source: lib/proto/assets.ubika.io/v1beta/asset.proto

package v1beta

import (
	"bytes"
	"errors"
	"fmt"
	"net"
	"net/mail"
	"net/url"
	"regexp"
	"sort"
	"strings"
	"time"
	"unicode/utf8"

	"google.golang.org/protobuf/types/known/anypb"

	crypto "github.com/ubikasec/terraform-provider-ubika/internal/crypto"
)

// ensure the imports are used
var (
	_ = bytes.MinRead
	_ = errors.New("")
	_ = fmt.Print
	_ = utf8.UTFMax
	_ = (*regexp.Regexp)(nil)
	_ = (*strings.Reader)(nil)
	_ = net.IPv4len
	_ = time.Duration(0)
	_ = (*url.URL)(nil)
	_ = (*mail.Address)(nil)
	_ = anypb.Any{}
	_ = sort.Sort

	_ = crypto.TLSProtocol_Enum(0)
)

// Validate checks the field values on SecurityMode with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *SecurityMode) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on SecurityMode with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in SecurityModeMultiError, or
// nil if none found.
func (m *SecurityMode) ValidateAll() error {
	return m.validate(true)
}

func (m *SecurityMode) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return SecurityModeMultiError(errors)
	}

	return nil
}

// SecurityModeMultiError is an error wrapping multiple validation errors
// returned by SecurityMode.ValidateAll() if the designated constraints aren't met.
type SecurityModeMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m SecurityModeMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m SecurityModeMultiError) AllErrors() []error { return m }

// SecurityModeValidationError is the validation error returned by
// SecurityMode.Validate if the designated constraints aren't met.
type SecurityModeValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e SecurityModeValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e SecurityModeValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e SecurityModeValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e SecurityModeValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e SecurityModeValidationError) ErrorName() string { return "SecurityModeValidationError" }

// Error satisfies the builtin error interface
func (e SecurityModeValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sSecurityMode.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = SecurityModeValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = SecurityModeValidationError{}

// Validate checks the field values on ExceptionProfileSpec with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ExceptionProfileSpec) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ExceptionProfileSpec with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ExceptionProfileSpecMultiError, or nil if none found.
func (m *ExceptionProfileSpec) ValidateAll() error {
	return m.validate(true)
}

func (m *ExceptionProfileSpec) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetRules() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ExceptionProfileSpecValidationError{
						field:  fmt.Sprintf("Rules[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ExceptionProfileSpecValidationError{
						field:  fmt.Sprintf("Rules[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ExceptionProfileSpecValidationError{
					field:  fmt.Sprintf("Rules[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return ExceptionProfileSpecMultiError(errors)
	}

	return nil
}

// ExceptionProfileSpecMultiError is an error wrapping multiple validation
// errors returned by ExceptionProfileSpec.ValidateAll() if the designated
// constraints aren't met.
type ExceptionProfileSpecMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ExceptionProfileSpecMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ExceptionProfileSpecMultiError) AllErrors() []error { return m }

// ExceptionProfileSpecValidationError is the validation error returned by
// ExceptionProfileSpec.Validate if the designated constraints aren't met.
type ExceptionProfileSpecValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ExceptionProfileSpecValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ExceptionProfileSpecValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ExceptionProfileSpecValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ExceptionProfileSpecValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ExceptionProfileSpecValidationError) ErrorName() string {
	return "ExceptionProfileSpecValidationError"
}

// Error satisfies the builtin error interface
func (e ExceptionProfileSpecValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sExceptionProfileSpec.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ExceptionProfileSpecValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ExceptionProfileSpecValidationError{}

// Validate checks the field values on ExceptionProfile with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *ExceptionProfile) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ExceptionProfile with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ExceptionProfileMultiError, or nil if none found.
func (m *ExceptionProfile) ValidateAll() error {
	return m.validate(true)
}

func (m *ExceptionProfile) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if m.GetApiVersion() != "assets.ubika.io/v1beta" {
		err := ExceptionProfileValidationError{
			field:  "ApiVersion",
			reason: "value must equal assets.ubika.io/v1beta",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if m.GetKind() != "ExceptionProfile" {
		err := ExceptionProfileValidationError{
			field:  "Kind",
			reason: "value must equal ExceptionProfile",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if m.GetMetadata() == nil {
		err := ExceptionProfileValidationError{
			field:  "Metadata",
			reason: "value is required",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if all {
		switch v := interface{}(m.GetMetadata()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ExceptionProfileValidationError{
					field:  "Metadata",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ExceptionProfileValidationError{
					field:  "Metadata",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetMetadata()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ExceptionProfileValidationError{
				field:  "Metadata",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if m.GetSpec() == nil {
		err := ExceptionProfileValidationError{
			field:  "Spec",
			reason: "value is required",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if all {
		switch v := interface{}(m.GetSpec()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ExceptionProfileValidationError{
					field:  "Spec",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ExceptionProfileValidationError{
					field:  "Spec",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetSpec()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ExceptionProfileValidationError{
				field:  "Spec",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return ExceptionProfileMultiError(errors)
	}

	return nil
}

// ExceptionProfileMultiError is an error wrapping multiple validation errors
// returned by ExceptionProfile.ValidateAll() if the designated constraints
// aren't met.
type ExceptionProfileMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ExceptionProfileMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ExceptionProfileMultiError) AllErrors() []error { return m }

// ExceptionProfileValidationError is the validation error returned by
// ExceptionProfile.Validate if the designated constraints aren't met.
type ExceptionProfileValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ExceptionProfileValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ExceptionProfileValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ExceptionProfileValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ExceptionProfileValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ExceptionProfileValidationError) ErrorName() string { return "ExceptionProfileValidationError" }

// Error satisfies the builtin error interface
func (e ExceptionProfileValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sExceptionProfile.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ExceptionProfileValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ExceptionProfileValidationError{}

// Validate checks the field values on ExceptionProfileList with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ExceptionProfileList) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ExceptionProfileList with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ExceptionProfileListMultiError, or nil if none found.
func (m *ExceptionProfileList) ValidateAll() error {
	return m.validate(true)
}

func (m *ExceptionProfileList) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if m.GetApiVersion() != "assets.ubika.io/v1beta" {
		err := ExceptionProfileListValidationError{
			field:  "ApiVersion",
			reason: "value must equal assets.ubika.io/v1beta",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if m.GetKind() != "ExceptionProfileList" {
		err := ExceptionProfileListValidationError{
			field:  "Kind",
			reason: "value must equal ExceptionProfileList",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if all {
		switch v := interface{}(m.GetMetadata()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ExceptionProfileListValidationError{
					field:  "Metadata",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ExceptionProfileListValidationError{
					field:  "Metadata",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetMetadata()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ExceptionProfileListValidationError{
				field:  "Metadata",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	for idx, item := range m.GetItems() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ExceptionProfileListValidationError{
						field:  fmt.Sprintf("Items[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ExceptionProfileListValidationError{
						field:  fmt.Sprintf("Items[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ExceptionProfileListValidationError{
					field:  fmt.Sprintf("Items[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return ExceptionProfileListMultiError(errors)
	}

	return nil
}

// ExceptionProfileListMultiError is an error wrapping multiple validation
// errors returned by ExceptionProfileList.ValidateAll() if the designated
// constraints aren't met.
type ExceptionProfileListMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ExceptionProfileListMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ExceptionProfileListMultiError) AllErrors() []error { return m }

// ExceptionProfileListValidationError is the validation error returned by
// ExceptionProfileList.Validate if the designated constraints aren't met.
type ExceptionProfileListValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ExceptionProfileListValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ExceptionProfileListValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ExceptionProfileListValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ExceptionProfileListValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ExceptionProfileListValidationError) ErrorName() string {
	return "ExceptionProfileListValidationError"
}

// Error satisfies the builtin error interface
func (e ExceptionProfileListValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sExceptionProfileList.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ExceptionProfileListValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ExceptionProfileListValidationError{}

// Validate checks the field values on APIModule with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *APIModule) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on APIModule with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in APIModuleMultiError, or nil
// if none found.
func (m *APIModule) ValidateAll() error {
	return m.validate(true)
}

func (m *APIModule) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for SecurityMode

	if m.GetOpenapi() != "" {

		if utf8.RuneCountInString(m.GetOpenapi()) > 63 {
			err := APIModuleValidationError{
				field:  "Openapi",
				reason: "value length must be at most 63 runes",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if err := m._validateHostname(m.GetOpenapi()); err != nil {
			err = APIModuleValidationError{
				field:  "Openapi",
				reason: "value must be a valid hostname",
				cause:  err,
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

	}

	if len(errors) > 0 {
		return APIModuleMultiError(errors)
	}

	return nil
}

func (m *APIModule) _validateHostname(host string) error {
	s := strings.ToLower(strings.TrimSuffix(host, "."))

	if len(host) > 253 {
		return errors.New("hostname cannot exceed 253 characters")
	}

	for _, part := range strings.Split(s, ".") {
		if l := len(part); l == 0 || l > 63 {
			return errors.New("hostname part must be non-empty and cannot exceed 63 characters")
		}

		if part[0] == '-' {
			return errors.New("hostname parts cannot begin with hyphens")
		}

		if part[len(part)-1] == '-' {
			return errors.New("hostname parts cannot end with hyphens")
		}

		for _, r := range part {
			if (r < 'a' || r > 'z') && (r < '0' || r > '9') && r != '-' {
				return fmt.Errorf("hostname parts can only contain alphanumeric characters or hyphens, got %q", string(r))
			}
		}
	}

	return nil
}

// APIModuleMultiError is an error wrapping multiple validation errors returned
// by APIModule.ValidateAll() if the designated constraints aren't met.
type APIModuleMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m APIModuleMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m APIModuleMultiError) AllErrors() []error { return m }

// APIModuleValidationError is the validation error returned by
// APIModule.Validate if the designated constraints aren't met.
type APIModuleValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e APIModuleValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e APIModuleValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e APIModuleValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e APIModuleValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e APIModuleValidationError) ErrorName() string { return "APIModuleValidationError" }

// Error satisfies the builtin error interface
func (e APIModuleValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sAPIModule.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = APIModuleValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = APIModuleValidationError{}

// Validate checks the field values on ApplicationModule with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *ApplicationModule) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ApplicationModule with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ApplicationModuleMultiError, or nil if none found.
func (m *ApplicationModule) ValidateAll() error {
	return m.validate(true)
}

func (m *ApplicationModule) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for SecurityMode

	if m.GetExceptionProfile() != "" {

		if utf8.RuneCountInString(m.GetExceptionProfile()) > 63 {
			err := ApplicationModuleValidationError{
				field:  "ExceptionProfile",
				reason: "value length must be at most 63 runes",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if err := m._validateHostname(m.GetExceptionProfile()); err != nil {
			err = ApplicationModuleValidationError{
				field:  "ExceptionProfile",
				reason: "value must be a valid hostname",
				cause:  err,
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

	}

	if len(errors) > 0 {
		return ApplicationModuleMultiError(errors)
	}

	return nil
}

func (m *ApplicationModule) _validateHostname(host string) error {
	s := strings.ToLower(strings.TrimSuffix(host, "."))

	if len(host) > 253 {
		return errors.New("hostname cannot exceed 253 characters")
	}

	for _, part := range strings.Split(s, ".") {
		if l := len(part); l == 0 || l > 63 {
			return errors.New("hostname part must be non-empty and cannot exceed 63 characters")
		}

		if part[0] == '-' {
			return errors.New("hostname parts cannot begin with hyphens")
		}

		if part[len(part)-1] == '-' {
			return errors.New("hostname parts cannot end with hyphens")
		}

		for _, r := range part {
			if (r < 'a' || r > 'z') && (r < '0' || r > '9') && r != '-' {
				return fmt.Errorf("hostname parts can only contain alphanumeric characters or hyphens, got %q", string(r))
			}
		}
	}

	return nil
}

// ApplicationModuleMultiError is an error wrapping multiple validation errors
// returned by ApplicationModule.ValidateAll() if the designated constraints
// aren't met.
type ApplicationModuleMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ApplicationModuleMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ApplicationModuleMultiError) AllErrors() []error { return m }

// ApplicationModuleValidationError is the validation error returned by
// ApplicationModule.Validate if the designated constraints aren't met.
type ApplicationModuleValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ApplicationModuleValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ApplicationModuleValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ApplicationModuleValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ApplicationModuleValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ApplicationModuleValidationError) ErrorName() string {
	return "ApplicationModuleValidationError"
}

// Error satisfies the builtin error interface
func (e ApplicationModuleValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sApplicationModule.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ApplicationModuleValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ApplicationModuleValidationError{}

// Validate checks the field values on Workflow with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Workflow) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Workflow with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in WorkflowMultiError, or nil
// if none found.
func (m *Workflow) ValidateAll() error {
	return m.validate(true)
}

func (m *Workflow) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if m.GetApiVersion() != "assets.ubika.io/v1beta" {
		err := WorkflowValidationError{
			field:  "ApiVersion",
			reason: "value must equal assets.ubika.io/v1beta",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if m.GetKind() != "Workflow" {
		err := WorkflowValidationError{
			field:  "Kind",
			reason: "value must equal Workflow",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if m.GetMetadata() == nil {
		err := WorkflowValidationError{
			field:  "Metadata",
			reason: "value is required",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if all {
		switch v := interface{}(m.GetMetadata()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, WorkflowValidationError{
					field:  "Metadata",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, WorkflowValidationError{
					field:  "Metadata",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetMetadata()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return WorkflowValidationError{
				field:  "Metadata",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if m.GetSpec() == nil {
		err := WorkflowValidationError{
			field:  "Spec",
			reason: "value is required",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if all {
		switch v := interface{}(m.GetSpec()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, WorkflowValidationError{
					field:  "Spec",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, WorkflowValidationError{
					field:  "Spec",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetSpec()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return WorkflowValidationError{
				field:  "Spec",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return WorkflowMultiError(errors)
	}

	return nil
}

// WorkflowMultiError is an error wrapping multiple validation errors returned
// by Workflow.ValidateAll() if the designated constraints aren't met.
type WorkflowMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m WorkflowMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m WorkflowMultiError) AllErrors() []error { return m }

// WorkflowValidationError is the validation error returned by
// Workflow.Validate if the designated constraints aren't met.
type WorkflowValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e WorkflowValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e WorkflowValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e WorkflowValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e WorkflowValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e WorkflowValidationError) ErrorName() string { return "WorkflowValidationError" }

// Error satisfies the builtin error interface
func (e WorkflowValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sWorkflow.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = WorkflowValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = WorkflowValidationError{}

// Validate checks the field values on WorkflowList with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *WorkflowList) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on WorkflowList with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in WorkflowListMultiError, or
// nil if none found.
func (m *WorkflowList) ValidateAll() error {
	return m.validate(true)
}

func (m *WorkflowList) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for ApiVersion

	// no validation rules for Kind

	if all {
		switch v := interface{}(m.GetMetadata()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, WorkflowListValidationError{
					field:  "Metadata",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, WorkflowListValidationError{
					field:  "Metadata",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetMetadata()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return WorkflowListValidationError{
				field:  "Metadata",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	for idx, item := range m.GetItems() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, WorkflowListValidationError{
						field:  fmt.Sprintf("Items[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, WorkflowListValidationError{
						field:  fmt.Sprintf("Items[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return WorkflowListValidationError{
					field:  fmt.Sprintf("Items[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return WorkflowListMultiError(errors)
	}

	return nil
}

// WorkflowListMultiError is an error wrapping multiple validation errors
// returned by WorkflowList.ValidateAll() if the designated constraints aren't met.
type WorkflowListMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m WorkflowListMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m WorkflowListMultiError) AllErrors() []error { return m }

// WorkflowListValidationError is the validation error returned by
// WorkflowList.Validate if the designated constraints aren't met.
type WorkflowListValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e WorkflowListValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e WorkflowListValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e WorkflowListValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e WorkflowListValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e WorkflowListValidationError) ErrorName() string { return "WorkflowListValidationError" }

// Error satisfies the builtin error interface
func (e WorkflowListValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sWorkflowList.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = WorkflowListValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = WorkflowListValidationError{}

// Validate checks the field values on WorkflowSpec with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *WorkflowSpec) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on WorkflowSpec with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in WorkflowSpecMultiError, or
// nil if none found.
func (m *WorkflowSpec) ValidateAll() error {
	return m.validate(true)
}

func (m *WorkflowSpec) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Source

	// no validation rules for Entrypoint

	if len(errors) > 0 {
		return WorkflowSpecMultiError(errors)
	}

	return nil
}

// WorkflowSpecMultiError is an error wrapping multiple validation errors
// returned by WorkflowSpec.ValidateAll() if the designated constraints aren't met.
type WorkflowSpecMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m WorkflowSpecMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m WorkflowSpecMultiError) AllErrors() []error { return m }

// WorkflowSpecValidationError is the validation error returned by
// WorkflowSpec.Validate if the designated constraints aren't met.
type WorkflowSpecValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e WorkflowSpecValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e WorkflowSpecValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e WorkflowSpecValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e WorkflowSpecValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e WorkflowSpecValidationError) ErrorName() string { return "WorkflowSpecValidationError" }

// Error satisfies the builtin error interface
func (e WorkflowSpecValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sWorkflowSpec.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = WorkflowSpecValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = WorkflowSpecValidationError{}

// Validate checks the field values on CustomWkfModule with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *CustomWkfModule) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CustomWkfModule with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// CustomWkfModuleMultiError, or nil if none found.
func (m *CustomWkfModule) ValidateAll() error {
	return m.validate(true)
}

func (m *CustomWkfModule) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if m.GetWorkflow() != "" {

		if utf8.RuneCountInString(m.GetWorkflow()) > 63 {
			err := CustomWkfModuleValidationError{
				field:  "Workflow",
				reason: "value length must be at most 63 runes",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if err := m._validateHostname(m.GetWorkflow()); err != nil {
			err = CustomWkfModuleValidationError{
				field:  "Workflow",
				reason: "value must be a valid hostname",
				cause:  err,
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

	}

	// no validation rules for WorkflowParams

	if len(errors) > 0 {
		return CustomWkfModuleMultiError(errors)
	}

	return nil
}

func (m *CustomWkfModule) _validateHostname(host string) error {
	s := strings.ToLower(strings.TrimSuffix(host, "."))

	if len(host) > 253 {
		return errors.New("hostname cannot exceed 253 characters")
	}

	for _, part := range strings.Split(s, ".") {
		if l := len(part); l == 0 || l > 63 {
			return errors.New("hostname part must be non-empty and cannot exceed 63 characters")
		}

		if part[0] == '-' {
			return errors.New("hostname parts cannot begin with hyphens")
		}

		if part[len(part)-1] == '-' {
			return errors.New("hostname parts cannot end with hyphens")
		}

		for _, r := range part {
			if (r < 'a' || r > 'z') && (r < '0' || r > '9') && r != '-' {
				return fmt.Errorf("hostname parts can only contain alphanumeric characters or hyphens, got %q", string(r))
			}
		}
	}

	return nil
}

// CustomWkfModuleMultiError is an error wrapping multiple validation errors
// returned by CustomWkfModule.ValidateAll() if the designated constraints
// aren't met.
type CustomWkfModuleMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CustomWkfModuleMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CustomWkfModuleMultiError) AllErrors() []error { return m }

// CustomWkfModuleValidationError is the validation error returned by
// CustomWkfModule.Validate if the designated constraints aren't met.
type CustomWkfModuleValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CustomWkfModuleValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CustomWkfModuleValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CustomWkfModuleValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CustomWkfModuleValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CustomWkfModuleValidationError) ErrorName() string { return "CustomWkfModuleValidationError" }

// Error satisfies the builtin error interface
func (e CustomWkfModuleValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCustomWkfModule.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CustomWkfModuleValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CustomWkfModuleValidationError{}

// Validate checks the field values on WebSocketSecurityMode with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *WebSocketSecurityMode) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on WebSocketSecurityMode with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// WebSocketSecurityModeMultiError, or nil if none found.
func (m *WebSocketSecurityMode) ValidateAll() error {
	return m.validate(true)
}

func (m *WebSocketSecurityMode) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return WebSocketSecurityModeMultiError(errors)
	}

	return nil
}

// WebSocketSecurityModeMultiError is an error wrapping multiple validation
// errors returned by WebSocketSecurityMode.ValidateAll() if the designated
// constraints aren't met.
type WebSocketSecurityModeMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m WebSocketSecurityModeMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m WebSocketSecurityModeMultiError) AllErrors() []error { return m }

// WebSocketSecurityModeValidationError is the validation error returned by
// WebSocketSecurityMode.Validate if the designated constraints aren't met.
type WebSocketSecurityModeValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e WebSocketSecurityModeValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e WebSocketSecurityModeValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e WebSocketSecurityModeValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e WebSocketSecurityModeValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e WebSocketSecurityModeValidationError) ErrorName() string {
	return "WebSocketSecurityModeValidationError"
}

// Error satisfies the builtin error interface
func (e WebSocketSecurityModeValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sWebSocketSecurityMode.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = WebSocketSecurityModeValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = WebSocketSecurityModeValidationError{}

// Validate checks the field values on WebSocketModule with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *WebSocketModule) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on WebSocketModule with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// WebSocketModuleMultiError, or nil if none found.
func (m *WebSocketModule) ValidateAll() error {
	return m.validate(true)
}

func (m *WebSocketModule) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for SecurityMode

	if len(errors) > 0 {
		return WebSocketModuleMultiError(errors)
	}

	return nil
}

// WebSocketModuleMultiError is an error wrapping multiple validation errors
// returned by WebSocketModule.ValidateAll() if the designated constraints
// aren't met.
type WebSocketModuleMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m WebSocketModuleMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m WebSocketModuleMultiError) AllErrors() []error { return m }

// WebSocketModuleValidationError is the validation error returned by
// WebSocketModule.Validate if the designated constraints aren't met.
type WebSocketModuleValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e WebSocketModuleValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e WebSocketModuleValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e WebSocketModuleValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e WebSocketModuleValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e WebSocketModuleValidationError) ErrorName() string { return "WebSocketModuleValidationError" }

// Error satisfies the builtin error interface
func (e WebSocketModuleValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sWebSocketModule.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = WebSocketModuleValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = WebSocketModuleValidationError{}

// Validate checks the field values on IPReputationThreat with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *IPReputationThreat) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on IPReputationThreat with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// IPReputationThreatMultiError, or nil if none found.
func (m *IPReputationThreat) ValidateAll() error {
	return m.validate(true)
}

func (m *IPReputationThreat) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return IPReputationThreatMultiError(errors)
	}

	return nil
}

// IPReputationThreatMultiError is an error wrapping multiple validation errors
// returned by IPReputationThreat.ValidateAll() if the designated constraints
// aren't met.
type IPReputationThreatMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m IPReputationThreatMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m IPReputationThreatMultiError) AllErrors() []error { return m }

// IPReputationThreatValidationError is the validation error returned by
// IPReputationThreat.Validate if the designated constraints aren't met.
type IPReputationThreatValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e IPReputationThreatValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e IPReputationThreatValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e IPReputationThreatValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e IPReputationThreatValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e IPReputationThreatValidationError) ErrorName() string {
	return "IPReputationThreatValidationError"
}

// Error satisfies the builtin error interface
func (e IPReputationThreatValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sIPReputationThreat.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = IPReputationThreatValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = IPReputationThreatValidationError{}

// Validate checks the field values on IPReputationModule with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *IPReputationModule) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on IPReputationModule with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// IPReputationModuleMultiError, or nil if none found.
func (m *IPReputationModule) ValidateAll() error {
	return m.validate(true)
}

func (m *IPReputationModule) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for SecurityMode

	if len(errors) > 0 {
		return IPReputationModuleMultiError(errors)
	}

	return nil
}

// IPReputationModuleMultiError is an error wrapping multiple validation errors
// returned by IPReputationModule.ValidateAll() if the designated constraints
// aren't met.
type IPReputationModuleMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m IPReputationModuleMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m IPReputationModuleMultiError) AllErrors() []error { return m }

// IPReputationModuleValidationError is the validation error returned by
// IPReputationModule.Validate if the designated constraints aren't met.
type IPReputationModuleValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e IPReputationModuleValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e IPReputationModuleValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e IPReputationModuleValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e IPReputationModuleValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e IPReputationModuleValidationError) ErrorName() string {
	return "IPReputationModuleValidationError"
}

// Error satisfies the builtin error interface
func (e IPReputationModuleValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sIPReputationModule.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = IPReputationModuleValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = IPReputationModuleValidationError{}

// Validate checks the field values on GeoIPMode with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *GeoIPMode) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GeoIPMode with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in GeoIPModeMultiError, or nil
// if none found.
func (m *GeoIPMode) ValidateAll() error {
	return m.validate(true)
}

func (m *GeoIPMode) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return GeoIPModeMultiError(errors)
	}

	return nil
}

// GeoIPModeMultiError is an error wrapping multiple validation errors returned
// by GeoIPMode.ValidateAll() if the designated constraints aren't met.
type GeoIPModeMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GeoIPModeMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GeoIPModeMultiError) AllErrors() []error { return m }

// GeoIPModeValidationError is the validation error returned by
// GeoIPMode.Validate if the designated constraints aren't met.
type GeoIPModeValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GeoIPModeValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GeoIPModeValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GeoIPModeValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GeoIPModeValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GeoIPModeValidationError) ErrorName() string { return "GeoIPModeValidationError" }

// Error satisfies the builtin error interface
func (e GeoIPModeValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGeoIPMode.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GeoIPModeValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GeoIPModeValidationError{}

// Validate checks the field values on GeoIPModule with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *GeoIPModule) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GeoIPModule with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in GeoIPModuleMultiError, or
// nil if none found.
func (m *GeoIPModule) ValidateAll() error {
	return m.validate(true)
}

func (m *GeoIPModule) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for SecurityMode

	if len(m.GetCountries()) > 250 {
		err := GeoIPModuleValidationError{
			field:  "Countries",
			reason: "value must contain no more than 250 item(s)",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	for idx, item := range m.GetCountries() {
		_, _ = idx, item

		if utf8.RuneCountInString(item) != 2 {
			err := GeoIPModuleValidationError{
				field:  fmt.Sprintf("Countries[%v]", idx),
				reason: "value length must be 2 runes",
			}
			if !all {
				return err
			}
			errors = append(errors, err)

		}

		if !_GeoIPModule_Countries_Pattern.MatchString(item) {
			err := GeoIPModuleValidationError{
				field:  fmt.Sprintf("Countries[%v]", idx),
				reason: "value does not match regex pattern \"^[A-Z]{2}$\"",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

	}

	// no validation rules for Mode

	if len(errors) > 0 {
		return GeoIPModuleMultiError(errors)
	}

	return nil
}

// GeoIPModuleMultiError is an error wrapping multiple validation errors
// returned by GeoIPModule.ValidateAll() if the designated constraints aren't met.
type GeoIPModuleMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GeoIPModuleMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GeoIPModuleMultiError) AllErrors() []error { return m }

// GeoIPModuleValidationError is the validation error returned by
// GeoIPModule.Validate if the designated constraints aren't met.
type GeoIPModuleValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GeoIPModuleValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GeoIPModuleValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GeoIPModuleValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GeoIPModuleValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GeoIPModuleValidationError) ErrorName() string { return "GeoIPModuleValidationError" }

// Error satisfies the builtin error interface
func (e GeoIPModuleValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGeoIPModule.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GeoIPModuleValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GeoIPModuleValidationError{}

var _GeoIPModule_Countries_Pattern = regexp.MustCompile("^[A-Z]{2}$")

// Validate checks the field values on IPBlacklistModule with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *IPBlacklistModule) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on IPBlacklistModule with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// IPBlacklistModuleMultiError, or nil if none found.
func (m *IPBlacklistModule) ValidateAll() error {
	return m.validate(true)
}

func (m *IPBlacklistModule) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for SecurityMode

	if m.GetIpBlacklist() != "" {

		if utf8.RuneCountInString(m.GetIpBlacklist()) > 63 {
			err := IPBlacklistModuleValidationError{
				field:  "IpBlacklist",
				reason: "value length must be at most 63 runes",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if err := m._validateHostname(m.GetIpBlacklist()); err != nil {
			err = IPBlacklistModuleValidationError{
				field:  "IpBlacklist",
				reason: "value must be a valid hostname",
				cause:  err,
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

	}

	if len(errors) > 0 {
		return IPBlacklistModuleMultiError(errors)
	}

	return nil
}

func (m *IPBlacklistModule) _validateHostname(host string) error {
	s := strings.ToLower(strings.TrimSuffix(host, "."))

	if len(host) > 253 {
		return errors.New("hostname cannot exceed 253 characters")
	}

	for _, part := range strings.Split(s, ".") {
		if l := len(part); l == 0 || l > 63 {
			return errors.New("hostname part must be non-empty and cannot exceed 63 characters")
		}

		if part[0] == '-' {
			return errors.New("hostname parts cannot begin with hyphens")
		}

		if part[len(part)-1] == '-' {
			return errors.New("hostname parts cannot end with hyphens")
		}

		for _, r := range part {
			if (r < 'a' || r > 'z') && (r < '0' || r > '9') && r != '-' {
				return fmt.Errorf("hostname parts can only contain alphanumeric characters or hyphens, got %q", string(r))
			}
		}
	}

	return nil
}

// IPBlacklistModuleMultiError is an error wrapping multiple validation errors
// returned by IPBlacklistModule.ValidateAll() if the designated constraints
// aren't met.
type IPBlacklistModuleMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m IPBlacklistModuleMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m IPBlacklistModuleMultiError) AllErrors() []error { return m }

// IPBlacklistModuleValidationError is the validation error returned by
// IPBlacklistModule.Validate if the designated constraints aren't met.
type IPBlacklistModuleValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e IPBlacklistModuleValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e IPBlacklistModuleValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e IPBlacklistModuleValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e IPBlacklistModuleValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e IPBlacklistModuleValidationError) ErrorName() string {
	return "IPBlacklistModuleValidationError"
}

// Error satisfies the builtin error interface
func (e IPBlacklistModuleValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sIPBlacklistModule.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = IPBlacklistModuleValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = IPBlacklistModuleValidationError{}

// Validate checks the field values on AssetSpec with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *AssetSpec) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on AssetSpec with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in AssetSpecMultiError, or nil
// if none found.
func (m *AssetSpec) ValidateAll() error {
	return m.validate(true)
}

func (m *AssetSpec) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if l := len(m.GetHostnames()); l < 1 || l > 100 {
		err := AssetSpecValidationError{
			field:  "Hostnames",
			reason: "value must contain between 1 and 100 items, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	for idx, item := range m.GetHostnames() {
		_, _ = idx, item

		if err := m._validateHostname(item); err != nil {
			err = AssetSpecValidationError{
				field:  fmt.Sprintf("Hostnames[%v]", idx),
				reason: "value must be a valid hostname",
				cause:  err,
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

	}

	if utf8.RuneCountInString(m.GetBackendUrl()) < 5 {
		err := AssetSpecValidationError{
			field:  "BackendUrl",
			reason: "value length must be at least 5 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if uri, err := url.Parse(m.GetBackendUrl()); err != nil {
		err = AssetSpecValidationError{
			field:  "BackendUrl",
			reason: "value must be a valid URI",
			cause:  err,
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	} else if !uri.IsAbs() {
		err := AssetSpecValidationError{
			field:  "BackendUrl",
			reason: "value must be absolute",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for TlsMode

	if m.GetTlsMaterial() != "" {

		if utf8.RuneCountInString(m.GetTlsMaterial()) > 63 {
			err := AssetSpecValidationError{
				field:  "TlsMaterial",
				reason: "value length must be at most 63 runes",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if err := m._validateHostname(m.GetTlsMaterial()); err != nil {
			err = AssetSpecValidationError{
				field:  "TlsMaterial",
				reason: "value must be a valid hostname",
				cause:  err,
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

	}

	if m.GetTlsConfiguration() != "" {

		if utf8.RuneCountInString(m.GetTlsConfiguration()) > 63 {
			err := AssetSpecValidationError{
				field:  "TlsConfiguration",
				reason: "value length must be at most 63 runes",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if err := m._validateHostname(m.GetTlsConfiguration()); err != nil {
			err = AssetSpecValidationError{
				field:  "TlsConfiguration",
				reason: "value must be a valid hostname",
				cause:  err,
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

	}

	if m.GetBlockingPage() != "" {

		if utf8.RuneCountInString(m.GetBlockingPage()) > 63 {
			err := AssetSpecValidationError{
				field:  "BlockingPage",
				reason: "value length must be at most 63 runes",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if err := m._validateHostname(m.GetBlockingPage()); err != nil {
			err = AssetSpecValidationError{
				field:  "BlockingPage",
				reason: "value must be a valid hostname",
				cause:  err,
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

	}

	if _, ok := DeploymentType_Enum_name[int32(m.GetDeploymentType())]; !ok {
		err := AssetSpecValidationError{
			field:  "DeploymentType",
			reason: "value must be one of the defined enum values",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if m.GetExceptionProfile() != "" {

		if utf8.RuneCountInString(m.GetExceptionProfile()) > 63 {
			err := AssetSpecValidationError{
				field:  "ExceptionProfile",
				reason: "value length must be at most 63 runes",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if err := m._validateHostname(m.GetExceptionProfile()); err != nil {
			err = AssetSpecValidationError{
				field:  "ExceptionProfile",
				reason: "value must be a valid hostname",
				cause:  err,
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

	}

	if m.GetUnavailablePage() != "" {

		if utf8.RuneCountInString(m.GetUnavailablePage()) > 63 {
			err := AssetSpecValidationError{
				field:  "UnavailablePage",
				reason: "value length must be at most 63 runes",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if err := m._validateHostname(m.GetUnavailablePage()); err != nil {
			err = AssetSpecValidationError{
				field:  "UnavailablePage",
				reason: "value must be a valid hostname",
				cause:  err,
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

	}

	if m.GetMaintenancePage() != "" {

		if utf8.RuneCountInString(m.GetMaintenancePage()) > 63 {
			err := AssetSpecValidationError{
				field:  "MaintenancePage",
				reason: "value length must be at most 63 runes",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if err := m._validateHostname(m.GetMaintenancePage()); err != nil {
			err = AssetSpecValidationError{
				field:  "MaintenancePage",
				reason: "value must be a valid hostname",
				cause:  err,
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

	}

	// no validation rules for MaintenanceEnabled

	if m.GetTrustedIpAddressHeader() != "" {

		if !_AssetSpec_TrustedIpAddressHeader_Pattern.MatchString(m.GetTrustedIpAddressHeader()) {
			err := AssetSpecValidationError{
				field:  "TrustedIpAddressHeader",
				reason: "value does not match regex pattern \"^[a-zA-Z0-9_-]{0,40}$\"",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

	}

	if _, ok := BackendCertificateCheck_Enum_name[int32(m.GetBackendCertificateCheck())]; !ok {
		err := AssetSpecValidationError{
			field:  "BackendCertificateCheck",
			reason: "value must be one of the defined enum values",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if m.ApiModule != nil {

		if all {
			switch v := interface{}(m.GetApiModule()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, AssetSpecValidationError{
						field:  "ApiModule",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, AssetSpecValidationError{
						field:  "ApiModule",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetApiModule()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return AssetSpecValidationError{
					field:  "ApiModule",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if m.ApplicationModule != nil {

		if all {
			switch v := interface{}(m.GetApplicationModule()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, AssetSpecValidationError{
						field:  "ApplicationModule",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, AssetSpecValidationError{
						field:  "ApplicationModule",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetApplicationModule()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return AssetSpecValidationError{
					field:  "ApplicationModule",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if m.WebSocketModule != nil {

		if all {
			switch v := interface{}(m.GetWebSocketModule()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, AssetSpecValidationError{
						field:  "WebSocketModule",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, AssetSpecValidationError{
						field:  "WebSocketModule",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetWebSocketModule()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return AssetSpecValidationError{
					field:  "WebSocketModule",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if m.IpReputationModule != nil {

		if all {
			switch v := interface{}(m.GetIpReputationModule()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, AssetSpecValidationError{
						field:  "IpReputationModule",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, AssetSpecValidationError{
						field:  "IpReputationModule",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetIpReputationModule()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return AssetSpecValidationError{
					field:  "IpReputationModule",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if m.GeoIpModule != nil {

		if all {
			switch v := interface{}(m.GetGeoIpModule()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, AssetSpecValidationError{
						field:  "GeoIpModule",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, AssetSpecValidationError{
						field:  "GeoIpModule",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetGeoIpModule()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return AssetSpecValidationError{
					field:  "GeoIpModule",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if m.CustomWkfModule != nil {

		if all {
			switch v := interface{}(m.GetCustomWkfModule()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, AssetSpecValidationError{
						field:  "CustomWkfModule",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, AssetSpecValidationError{
						field:  "CustomWkfModule",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetCustomWkfModule()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return AssetSpecValidationError{
					field:  "CustomWkfModule",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if m.IpBlacklistModule != nil {

		if all {
			switch v := interface{}(m.GetIpBlacklistModule()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, AssetSpecValidationError{
						field:  "IpBlacklistModule",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, AssetSpecValidationError{
						field:  "IpBlacklistModule",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetIpBlacklistModule()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return AssetSpecValidationError{
					field:  "IpBlacklistModule",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return AssetSpecMultiError(errors)
	}

	return nil
}

func (m *AssetSpec) _validateHostname(host string) error {
	s := strings.ToLower(strings.TrimSuffix(host, "."))

	if len(host) > 253 {
		return errors.New("hostname cannot exceed 253 characters")
	}

	for _, part := range strings.Split(s, ".") {
		if l := len(part); l == 0 || l > 63 {
			return errors.New("hostname part must be non-empty and cannot exceed 63 characters")
		}

		if part[0] == '-' {
			return errors.New("hostname parts cannot begin with hyphens")
		}

		if part[len(part)-1] == '-' {
			return errors.New("hostname parts cannot end with hyphens")
		}

		for _, r := range part {
			if (r < 'a' || r > 'z') && (r < '0' || r > '9') && r != '-' {
				return fmt.Errorf("hostname parts can only contain alphanumeric characters or hyphens, got %q", string(r))
			}
		}
	}

	return nil
}

// AssetSpecMultiError is an error wrapping multiple validation errors returned
// by AssetSpec.ValidateAll() if the designated constraints aren't met.
type AssetSpecMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m AssetSpecMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m AssetSpecMultiError) AllErrors() []error { return m }

// AssetSpecValidationError is the validation error returned by
// AssetSpec.Validate if the designated constraints aren't met.
type AssetSpecValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e AssetSpecValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e AssetSpecValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e AssetSpecValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e AssetSpecValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e AssetSpecValidationError) ErrorName() string { return "AssetSpecValidationError" }

// Error satisfies the builtin error interface
func (e AssetSpecValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sAssetSpec.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = AssetSpecValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = AssetSpecValidationError{}

var _AssetSpec_TrustedIpAddressHeader_Pattern = regexp.MustCompile("^[a-zA-Z0-9_-]{0,40}$")

// Validate checks the field values on BackendState with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *BackendState) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on BackendState with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in BackendStateMultiError, or
// nil if none found.
func (m *BackendState) ValidateAll() error {
	return m.validate(true)
}

func (m *BackendState) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return BackendStateMultiError(errors)
	}

	return nil
}

// BackendStateMultiError is an error wrapping multiple validation errors
// returned by BackendState.ValidateAll() if the designated constraints aren't met.
type BackendStateMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m BackendStateMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m BackendStateMultiError) AllErrors() []error { return m }

// BackendStateValidationError is the validation error returned by
// BackendState.Validate if the designated constraints aren't met.
type BackendStateValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e BackendStateValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e BackendStateValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e BackendStateValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e BackendStateValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e BackendStateValidationError) ErrorName() string { return "BackendStateValidationError" }

// Error satisfies the builtin error interface
func (e BackendStateValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sBackendState.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = BackendStateValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = BackendStateValidationError{}

// Validate checks the field values on DeploymentType with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *DeploymentType) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on DeploymentType with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in DeploymentTypeMultiError,
// or nil if none found.
func (m *DeploymentType) ValidateAll() error {
	return m.validate(true)
}

func (m *DeploymentType) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return DeploymentTypeMultiError(errors)
	}

	return nil
}

// DeploymentTypeMultiError is an error wrapping multiple validation errors
// returned by DeploymentType.ValidateAll() if the designated constraints
// aren't met.
type DeploymentTypeMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DeploymentTypeMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DeploymentTypeMultiError) AllErrors() []error { return m }

// DeploymentTypeValidationError is the validation error returned by
// DeploymentType.Validate if the designated constraints aren't met.
type DeploymentTypeValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DeploymentTypeValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DeploymentTypeValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DeploymentTypeValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DeploymentTypeValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DeploymentTypeValidationError) ErrorName() string { return "DeploymentTypeValidationError" }

// Error satisfies the builtin error interface
func (e DeploymentTypeValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDeploymentType.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DeploymentTypeValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DeploymentTypeValidationError{}

// Validate checks the field values on BackendCertificateCheck with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *BackendCertificateCheck) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on BackendCertificateCheck with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// BackendCertificateCheckMultiError, or nil if none found.
func (m *BackendCertificateCheck) ValidateAll() error {
	return m.validate(true)
}

func (m *BackendCertificateCheck) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return BackendCertificateCheckMultiError(errors)
	}

	return nil
}

// BackendCertificateCheckMultiError is an error wrapping multiple validation
// errors returned by BackendCertificateCheck.ValidateAll() if the designated
// constraints aren't met.
type BackendCertificateCheckMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m BackendCertificateCheckMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m BackendCertificateCheckMultiError) AllErrors() []error { return m }

// BackendCertificateCheckValidationError is the validation error returned by
// BackendCertificateCheck.Validate if the designated constraints aren't met.
type BackendCertificateCheckValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e BackendCertificateCheckValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e BackendCertificateCheckValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e BackendCertificateCheckValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e BackendCertificateCheckValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e BackendCertificateCheckValidationError) ErrorName() string {
	return "BackendCertificateCheckValidationError"
}

// Error satisfies the builtin error interface
func (e BackendCertificateCheckValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sBackendCertificateCheck.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = BackendCertificateCheckValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = BackendCertificateCheckValidationError{}

// Validate checks the field values on DnsState with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *DnsState) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on DnsState with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in DnsStateMultiError, or nil
// if none found.
func (m *DnsState) ValidateAll() error {
	return m.validate(true)
}

func (m *DnsState) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return DnsStateMultiError(errors)
	}

	return nil
}

// DnsStateMultiError is an error wrapping multiple validation errors returned
// by DnsState.ValidateAll() if the designated constraints aren't met.
type DnsStateMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DnsStateMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DnsStateMultiError) AllErrors() []error { return m }

// DnsStateValidationError is the validation error returned by
// DnsState.Validate if the designated constraints aren't met.
type DnsStateValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DnsStateValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DnsStateValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DnsStateValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DnsStateValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DnsStateValidationError) ErrorName() string { return "DnsStateValidationError" }

// Error satisfies the builtin error interface
func (e DnsStateValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDnsState.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DnsStateValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DnsStateValidationError{}

// Validate checks the field values on AssetState with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *AssetState) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on AssetState with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in AssetStateMultiError, or
// nil if none found.
func (m *AssetState) ValidateAll() error {
	return m.validate(true)
}

func (m *AssetState) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Backend

	// no validation rules for Dns

	// no validation rules for Runningstate

	if len(errors) > 0 {
		return AssetStateMultiError(errors)
	}

	return nil
}

// AssetStateMultiError is an error wrapping multiple validation errors
// returned by AssetState.ValidateAll() if the designated constraints aren't met.
type AssetStateMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m AssetStateMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m AssetStateMultiError) AllErrors() []error { return m }

// AssetStateValidationError is the validation error returned by
// AssetState.Validate if the designated constraints aren't met.
type AssetStateValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e AssetStateValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e AssetStateValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e AssetStateValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e AssetStateValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e AssetStateValidationError) ErrorName() string { return "AssetStateValidationError" }

// Error satisfies the builtin error interface
func (e AssetStateValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sAssetState.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = AssetStateValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = AssetStateValidationError{}

// Validate checks the field values on RunningState with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *RunningState) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on RunningState with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in RunningStateMultiError, or
// nil if none found.
func (m *RunningState) ValidateAll() error {
	return m.validate(true)
}

func (m *RunningState) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return RunningStateMultiError(errors)
	}

	return nil
}

// RunningStateMultiError is an error wrapping multiple validation errors
// returned by RunningState.ValidateAll() if the designated constraints aren't met.
type RunningStateMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m RunningStateMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m RunningStateMultiError) AllErrors() []error { return m }

// RunningStateValidationError is the validation error returned by
// RunningState.Validate if the designated constraints aren't met.
type RunningStateValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e RunningStateValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e RunningStateValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e RunningStateValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e RunningStateValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e RunningStateValidationError) ErrorName() string { return "RunningStateValidationError" }

// Error satisfies the builtin error interface
func (e RunningStateValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sRunningState.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = RunningStateValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = RunningStateValidationError{}

// Validate checks the field values on TLSMode with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *TLSMode) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on TLSMode with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in TLSModeMultiError, or nil if none found.
func (m *TLSMode) ValidateAll() error {
	return m.validate(true)
}

func (m *TLSMode) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return TLSModeMultiError(errors)
	}

	return nil
}

// TLSModeMultiError is an error wrapping multiple validation errors returned
// by TLSMode.ValidateAll() if the designated constraints aren't met.
type TLSModeMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m TLSModeMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m TLSModeMultiError) AllErrors() []error { return m }

// TLSModeValidationError is the validation error returned by TLSMode.Validate
// if the designated constraints aren't met.
type TLSModeValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e TLSModeValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e TLSModeValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e TLSModeValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e TLSModeValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e TLSModeValidationError) ErrorName() string { return "TLSModeValidationError" }

// Error satisfies the builtin error interface
func (e TLSModeValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sTLSMode.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = TLSModeValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = TLSModeValidationError{}

// Validate checks the field values on AssetTlsState with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *AssetTlsState) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on AssetTlsState with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in AssetTlsStateMultiError, or
// nil if none found.
func (m *AssetTlsState) ValidateAll() error {
	return m.validate(true)
}

func (m *AssetTlsState) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for BeginsOn

	// no validation rules for ExpiresOn

	// no validation rules for Mode

	if len(errors) > 0 {
		return AssetTlsStateMultiError(errors)
	}

	return nil
}

// AssetTlsStateMultiError is an error wrapping multiple validation errors
// returned by AssetTlsState.ValidateAll() if the designated constraints
// aren't met.
type AssetTlsStateMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m AssetTlsStateMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m AssetTlsStateMultiError) AllErrors() []error { return m }

// AssetTlsStateValidationError is the validation error returned by
// AssetTlsState.Validate if the designated constraints aren't met.
type AssetTlsStateValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e AssetTlsStateValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e AssetTlsStateValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e AssetTlsStateValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e AssetTlsStateValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e AssetTlsStateValidationError) ErrorName() string { return "AssetTlsStateValidationError" }

// Error satisfies the builtin error interface
func (e AssetTlsStateValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sAssetTlsState.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = AssetTlsStateValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = AssetTlsStateValidationError{}

// Validate checks the field values on AssetStatus with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *AssetStatus) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on AssetStatus with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in AssetStatusMultiError, or
// nil if none found.
func (m *AssetStatus) ValidateAll() error {
	return m.validate(true)
}

func (m *AssetStatus) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for ServiceAddress

	if all {
		switch v := interface{}(m.GetState()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, AssetStatusValidationError{
					field:  "State",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, AssetStatusValidationError{
					field:  "State",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetState()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return AssetStatusValidationError{
				field:  "State",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetTls()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, AssetStatusValidationError{
					field:  "Tls",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, AssetStatusValidationError{
					field:  "Tls",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetTls()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return AssetStatusValidationError{
				field:  "Tls",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return AssetStatusMultiError(errors)
	}

	return nil
}

// AssetStatusMultiError is an error wrapping multiple validation errors
// returned by AssetStatus.ValidateAll() if the designated constraints aren't met.
type AssetStatusMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m AssetStatusMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m AssetStatusMultiError) AllErrors() []error { return m }

// AssetStatusValidationError is the validation error returned by
// AssetStatus.Validate if the designated constraints aren't met.
type AssetStatusValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e AssetStatusValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e AssetStatusValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e AssetStatusValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e AssetStatusValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e AssetStatusValidationError) ErrorName() string { return "AssetStatusValidationError" }

// Error satisfies the builtin error interface
func (e AssetStatusValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sAssetStatus.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = AssetStatusValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = AssetStatusValidationError{}

// Validate checks the field values on Asset with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Asset) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Asset with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in AssetMultiError, or nil if none found.
func (m *Asset) ValidateAll() error {
	return m.validate(true)
}

func (m *Asset) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if m.GetApiVersion() != "assets.ubika.io/v1beta" {
		err := AssetValidationError{
			field:  "ApiVersion",
			reason: "value must equal assets.ubika.io/v1beta",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if m.GetKind() != "Asset" {
		err := AssetValidationError{
			field:  "Kind",
			reason: "value must equal Asset",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if m.GetMetadata() == nil {
		err := AssetValidationError{
			field:  "Metadata",
			reason: "value is required",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if all {
		switch v := interface{}(m.GetMetadata()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, AssetValidationError{
					field:  "Metadata",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, AssetValidationError{
					field:  "Metadata",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetMetadata()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return AssetValidationError{
				field:  "Metadata",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if m.GetSpec() == nil {
		err := AssetValidationError{
			field:  "Spec",
			reason: "value is required",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if all {
		switch v := interface{}(m.GetSpec()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, AssetValidationError{
					field:  "Spec",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, AssetValidationError{
					field:  "Spec",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetSpec()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return AssetValidationError{
				field:  "Spec",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetStatus()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, AssetValidationError{
					field:  "Status",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, AssetValidationError{
					field:  "Status",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetStatus()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return AssetValidationError{
				field:  "Status",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return AssetMultiError(errors)
	}

	return nil
}

// AssetMultiError is an error wrapping multiple validation errors returned by
// Asset.ValidateAll() if the designated constraints aren't met.
type AssetMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m AssetMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m AssetMultiError) AllErrors() []error { return m }

// AssetValidationError is the validation error returned by Asset.Validate if
// the designated constraints aren't met.
type AssetValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e AssetValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e AssetValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e AssetValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e AssetValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e AssetValidationError) ErrorName() string { return "AssetValidationError" }

// Error satisfies the builtin error interface
func (e AssetValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sAsset.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = AssetValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = AssetValidationError{}

// Validate checks the field values on AssetList with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *AssetList) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on AssetList with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in AssetListMultiError, or nil
// if none found.
func (m *AssetList) ValidateAll() error {
	return m.validate(true)
}

func (m *AssetList) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if m.GetApiVersion() != "assets.ubika.io/v1beta" {
		err := AssetListValidationError{
			field:  "ApiVersion",
			reason: "value must equal assets.ubika.io/v1beta",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if m.GetKind() != "AssetList" {
		err := AssetListValidationError{
			field:  "Kind",
			reason: "value must equal AssetList",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if all {
		switch v := interface{}(m.GetMetadata()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, AssetListValidationError{
					field:  "Metadata",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, AssetListValidationError{
					field:  "Metadata",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetMetadata()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return AssetListValidationError{
				field:  "Metadata",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	for idx, item := range m.GetItems() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, AssetListValidationError{
						field:  fmt.Sprintf("Items[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, AssetListValidationError{
						field:  fmt.Sprintf("Items[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return AssetListValidationError{
					field:  fmt.Sprintf("Items[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return AssetListMultiError(errors)
	}

	return nil
}

// AssetListMultiError is an error wrapping multiple validation errors returned
// by AssetList.ValidateAll() if the designated constraints aren't met.
type AssetListMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m AssetListMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m AssetListMultiError) AllErrors() []error { return m }

// AssetListValidationError is the validation error returned by
// AssetList.Validate if the designated constraints aren't met.
type AssetListValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e AssetListValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e AssetListValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e AssetListValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e AssetListValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e AssetListValidationError) ErrorName() string { return "AssetListValidationError" }

// Error satisfies the builtin error interface
func (e AssetListValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sAssetList.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = AssetListValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = AssetListValidationError{}

// Validate checks the field values on OpenAPISpec with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *OpenAPISpec) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on OpenAPISpec with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in OpenAPISpecMultiError, or
// nil if none found.
func (m *OpenAPISpec) ValidateAll() error {
	return m.validate(true)
}

func (m *OpenAPISpec) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(m.GetSource()) > 2097152 {
		err := OpenAPISpecValidationError{
			field:  "Source",
			reason: "value length must be at most 2097152 bytes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return OpenAPISpecMultiError(errors)
	}

	return nil
}

// OpenAPISpecMultiError is an error wrapping multiple validation errors
// returned by OpenAPISpec.ValidateAll() if the designated constraints aren't met.
type OpenAPISpecMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m OpenAPISpecMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m OpenAPISpecMultiError) AllErrors() []error { return m }

// OpenAPISpecValidationError is the validation error returned by
// OpenAPISpec.Validate if the designated constraints aren't met.
type OpenAPISpecValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e OpenAPISpecValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e OpenAPISpecValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e OpenAPISpecValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e OpenAPISpecValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e OpenAPISpecValidationError) ErrorName() string { return "OpenAPISpecValidationError" }

// Error satisfies the builtin error interface
func (e OpenAPISpecValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sOpenAPISpec.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = OpenAPISpecValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = OpenAPISpecValidationError{}

// Validate checks the field values on OpenAPI with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *OpenAPI) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on OpenAPI with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in OpenAPIMultiError, or nil if none found.
func (m *OpenAPI) ValidateAll() error {
	return m.validate(true)
}

func (m *OpenAPI) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for ApiVersion

	// no validation rules for Kind

	if all {
		switch v := interface{}(m.GetMetadata()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, OpenAPIValidationError{
					field:  "Metadata",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, OpenAPIValidationError{
					field:  "Metadata",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetMetadata()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return OpenAPIValidationError{
				field:  "Metadata",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetSpec()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, OpenAPIValidationError{
					field:  "Spec",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, OpenAPIValidationError{
					field:  "Spec",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetSpec()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return OpenAPIValidationError{
				field:  "Spec",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return OpenAPIMultiError(errors)
	}

	return nil
}

// OpenAPIMultiError is an error wrapping multiple validation errors returned
// by OpenAPI.ValidateAll() if the designated constraints aren't met.
type OpenAPIMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m OpenAPIMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m OpenAPIMultiError) AllErrors() []error { return m }

// OpenAPIValidationError is the validation error returned by OpenAPI.Validate
// if the designated constraints aren't met.
type OpenAPIValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e OpenAPIValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e OpenAPIValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e OpenAPIValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e OpenAPIValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e OpenAPIValidationError) ErrorName() string { return "OpenAPIValidationError" }

// Error satisfies the builtin error interface
func (e OpenAPIValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sOpenAPI.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = OpenAPIValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = OpenAPIValidationError{}

// Validate checks the field values on OpenAPIList with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *OpenAPIList) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on OpenAPIList with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in OpenAPIListMultiError, or
// nil if none found.
func (m *OpenAPIList) ValidateAll() error {
	return m.validate(true)
}

func (m *OpenAPIList) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for ApiVersion

	// no validation rules for Kind

	if all {
		switch v := interface{}(m.GetMetadata()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, OpenAPIListValidationError{
					field:  "Metadata",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, OpenAPIListValidationError{
					field:  "Metadata",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetMetadata()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return OpenAPIListValidationError{
				field:  "Metadata",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	for idx, item := range m.GetItems() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, OpenAPIListValidationError{
						field:  fmt.Sprintf("Items[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, OpenAPIListValidationError{
						field:  fmt.Sprintf("Items[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return OpenAPIListValidationError{
					field:  fmt.Sprintf("Items[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return OpenAPIListMultiError(errors)
	}

	return nil
}

// OpenAPIListMultiError is an error wrapping multiple validation errors
// returned by OpenAPIList.ValidateAll() if the designated constraints aren't met.
type OpenAPIListMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m OpenAPIListMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m OpenAPIListMultiError) AllErrors() []error { return m }

// OpenAPIListValidationError is the validation error returned by
// OpenAPIList.Validate if the designated constraints aren't met.
type OpenAPIListValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e OpenAPIListValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e OpenAPIListValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e OpenAPIListValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e OpenAPIListValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e OpenAPIListValidationError) ErrorName() string { return "OpenAPIListValidationError" }

// Error satisfies the builtin error interface
func (e OpenAPIListValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sOpenAPIList.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = OpenAPIListValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = OpenAPIListValidationError{}

// Validate checks the field values on ErrorDocument with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *ErrorDocument) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ErrorDocument with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in ErrorDocumentMultiError, or
// nil if none found.
func (m *ErrorDocument) ValidateAll() error {
	return m.validate(true)
}

func (m *ErrorDocument) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if m.GetApiVersion() != "assets.ubika.io/v1beta" {
		err := ErrorDocumentValidationError{
			field:  "ApiVersion",
			reason: "value must equal assets.ubika.io/v1beta",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if m.GetKind() != "ErrorDocument" {
		err := ErrorDocumentValidationError{
			field:  "Kind",
			reason: "value must equal ErrorDocument",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if m.GetMetadata() == nil {
		err := ErrorDocumentValidationError{
			field:  "Metadata",
			reason: "value is required",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if all {
		switch v := interface{}(m.GetMetadata()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ErrorDocumentValidationError{
					field:  "Metadata",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ErrorDocumentValidationError{
					field:  "Metadata",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetMetadata()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ErrorDocumentValidationError{
				field:  "Metadata",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetSpec()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ErrorDocumentValidationError{
					field:  "Spec",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ErrorDocumentValidationError{
					field:  "Spec",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetSpec()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ErrorDocumentValidationError{
				field:  "Spec",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return ErrorDocumentMultiError(errors)
	}

	return nil
}

// ErrorDocumentMultiError is an error wrapping multiple validation errors
// returned by ErrorDocument.ValidateAll() if the designated constraints
// aren't met.
type ErrorDocumentMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ErrorDocumentMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ErrorDocumentMultiError) AllErrors() []error { return m }

// ErrorDocumentValidationError is the validation error returned by
// ErrorDocument.Validate if the designated constraints aren't met.
type ErrorDocumentValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ErrorDocumentValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ErrorDocumentValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ErrorDocumentValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ErrorDocumentValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ErrorDocumentValidationError) ErrorName() string { return "ErrorDocumentValidationError" }

// Error satisfies the builtin error interface
func (e ErrorDocumentValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sErrorDocument.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ErrorDocumentValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ErrorDocumentValidationError{}

// Validate checks the field values on ErrorDocumentSpec with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *ErrorDocumentSpec) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ErrorDocumentSpec with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ErrorDocumentSpecMultiError, or nil if none found.
func (m *ErrorDocumentSpec) ValidateAll() error {
	return m.validate(true)
}

func (m *ErrorDocumentSpec) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(m.GetPage()) > 2097152 {
		err := ErrorDocumentSpecValidationError{
			field:  "Page",
			reason: "value length must be at most 2097152 bytes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if m.GetContentType() != "" {

		if _, ok := _ErrorDocumentSpec_ContentType_InLookup[m.GetContentType()]; !ok {
			err := ErrorDocumentSpecValidationError{
				field:  "ContentType",
				reason: "value must be in list [text/html application/json]",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

	}

	if len(errors) > 0 {
		return ErrorDocumentSpecMultiError(errors)
	}

	return nil
}

// ErrorDocumentSpecMultiError is an error wrapping multiple validation errors
// returned by ErrorDocumentSpec.ValidateAll() if the designated constraints
// aren't met.
type ErrorDocumentSpecMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ErrorDocumentSpecMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ErrorDocumentSpecMultiError) AllErrors() []error { return m }

// ErrorDocumentSpecValidationError is the validation error returned by
// ErrorDocumentSpec.Validate if the designated constraints aren't met.
type ErrorDocumentSpecValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ErrorDocumentSpecValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ErrorDocumentSpecValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ErrorDocumentSpecValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ErrorDocumentSpecValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ErrorDocumentSpecValidationError) ErrorName() string {
	return "ErrorDocumentSpecValidationError"
}

// Error satisfies the builtin error interface
func (e ErrorDocumentSpecValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sErrorDocumentSpec.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ErrorDocumentSpecValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ErrorDocumentSpecValidationError{}

var _ErrorDocumentSpec_ContentType_InLookup = map[string]struct{}{
	"text/html":        {},
	"application/json": {},
}

// Validate checks the field values on ErrorDocumentList with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *ErrorDocumentList) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ErrorDocumentList with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ErrorDocumentListMultiError, or nil if none found.
func (m *ErrorDocumentList) ValidateAll() error {
	return m.validate(true)
}

func (m *ErrorDocumentList) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for ApiVersion

	// no validation rules for Kind

	if all {
		switch v := interface{}(m.GetMetadata()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ErrorDocumentListValidationError{
					field:  "Metadata",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ErrorDocumentListValidationError{
					field:  "Metadata",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetMetadata()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ErrorDocumentListValidationError{
				field:  "Metadata",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	for idx, item := range m.GetItems() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ErrorDocumentListValidationError{
						field:  fmt.Sprintf("Items[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ErrorDocumentListValidationError{
						field:  fmt.Sprintf("Items[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ErrorDocumentListValidationError{
					field:  fmt.Sprintf("Items[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return ErrorDocumentListMultiError(errors)
	}

	return nil
}

// ErrorDocumentListMultiError is an error wrapping multiple validation errors
// returned by ErrorDocumentList.ValidateAll() if the designated constraints
// aren't met.
type ErrorDocumentListMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ErrorDocumentListMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ErrorDocumentListMultiError) AllErrors() []error { return m }

// ErrorDocumentListValidationError is the validation error returned by
// ErrorDocumentList.Validate if the designated constraints aren't met.
type ErrorDocumentListValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ErrorDocumentListValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ErrorDocumentListValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ErrorDocumentListValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ErrorDocumentListValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ErrorDocumentListValidationError) ErrorName() string {
	return "ErrorDocumentListValidationError"
}

// Error satisfies the builtin error interface
func (e ErrorDocumentListValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sErrorDocumentList.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ErrorDocumentListValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ErrorDocumentListValidationError{}

// Validate checks the field values on CSRStatus with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *CSRStatus) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CSRStatus with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in CSRStatusMultiError, or nil
// if none found.
func (m *CSRStatus) ValidateAll() error {
	return m.validate(true)
}

func (m *CSRStatus) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if utf8.RuneCountInString(m.GetAsset()) > 63 {
		err := CSRStatusValidationError{
			field:  "Asset",
			reason: "value length must be at most 63 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if err := m._validateHostname(m.GetAsset()); err != nil {
		err = CSRStatusValidationError{
			field:  "Asset",
			reason: "value must be a valid hostname",
			cause:  err,
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	for idx, item := range m.GetHostnames() {
		_, _ = idx, item

		if err := m._validateHostname(item); err != nil {
			err = CSRStatusValidationError{
				field:  fmt.Sprintf("Hostnames[%v]", idx),
				reason: "value must be a valid hostname",
				cause:  err,
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

	}

	// no validation rules for Mode

	if len(errors) > 0 {
		return CSRStatusMultiError(errors)
	}

	return nil
}

func (m *CSRStatus) _validateHostname(host string) error {
	s := strings.ToLower(strings.TrimSuffix(host, "."))

	if len(host) > 253 {
		return errors.New("hostname cannot exceed 253 characters")
	}

	for _, part := range strings.Split(s, ".") {
		if l := len(part); l == 0 || l > 63 {
			return errors.New("hostname part must be non-empty and cannot exceed 63 characters")
		}

		if part[0] == '-' {
			return errors.New("hostname parts cannot begin with hyphens")
		}

		if part[len(part)-1] == '-' {
			return errors.New("hostname parts cannot end with hyphens")
		}

		for _, r := range part {
			if (r < 'a' || r > 'z') && (r < '0' || r > '9') && r != '-' {
				return fmt.Errorf("hostname parts can only contain alphanumeric characters or hyphens, got %q", string(r))
			}
		}
	}

	return nil
}

// CSRStatusMultiError is an error wrapping multiple validation errors returned
// by CSRStatus.ValidateAll() if the designated constraints aren't met.
type CSRStatusMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CSRStatusMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CSRStatusMultiError) AllErrors() []error { return m }

// CSRStatusValidationError is the validation error returned by
// CSRStatus.Validate if the designated constraints aren't met.
type CSRStatusValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CSRStatusValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CSRStatusValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CSRStatusValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CSRStatusValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CSRStatusValidationError) ErrorName() string { return "CSRStatusValidationError" }

// Error satisfies the builtin error interface
func (e CSRStatusValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCSRStatus.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CSRStatusValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CSRStatusValidationError{}

// Validate checks the field values on CSRCreateSpec with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *CSRCreateSpec) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CSRCreateSpec with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in CSRCreateSpecMultiError, or
// nil if none found.
func (m *CSRCreateSpec) ValidateAll() error {
	return m.validate(true)
}

func (m *CSRCreateSpec) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if utf8.RuneCountInString(m.GetAsset()) > 63 {
		err := CSRCreateSpecValidationError{
			field:  "Asset",
			reason: "value length must be at most 63 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if err := m._validateHostname(m.GetAsset()); err != nil {
		err = CSRCreateSpecValidationError{
			field:  "Asset",
			reason: "value must be a valid hostname",
			cause:  err,
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return CSRCreateSpecMultiError(errors)
	}

	return nil
}

func (m *CSRCreateSpec) _validateHostname(host string) error {
	s := strings.ToLower(strings.TrimSuffix(host, "."))

	if len(host) > 253 {
		return errors.New("hostname cannot exceed 253 characters")
	}

	for _, part := range strings.Split(s, ".") {
		if l := len(part); l == 0 || l > 63 {
			return errors.New("hostname part must be non-empty and cannot exceed 63 characters")
		}

		if part[0] == '-' {
			return errors.New("hostname parts cannot begin with hyphens")
		}

		if part[len(part)-1] == '-' {
			return errors.New("hostname parts cannot end with hyphens")
		}

		for _, r := range part {
			if (r < 'a' || r > 'z') && (r < '0' || r > '9') && r != '-' {
				return fmt.Errorf("hostname parts can only contain alphanumeric characters or hyphens, got %q", string(r))
			}
		}
	}

	return nil
}

// CSRCreateSpecMultiError is an error wrapping multiple validation errors
// returned by CSRCreateSpec.ValidateAll() if the designated constraints
// aren't met.
type CSRCreateSpecMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CSRCreateSpecMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CSRCreateSpecMultiError) AllErrors() []error { return m }

// CSRCreateSpecValidationError is the validation error returned by
// CSRCreateSpec.Validate if the designated constraints aren't met.
type CSRCreateSpecValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CSRCreateSpecValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CSRCreateSpecValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CSRCreateSpecValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CSRCreateSpecValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CSRCreateSpecValidationError) ErrorName() string { return "CSRCreateSpecValidationError" }

// Error satisfies the builtin error interface
func (e CSRCreateSpecValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCSRCreateSpec.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CSRCreateSpecValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CSRCreateSpecValidationError{}

// Validate checks the field values on CSRCreate with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *CSRCreate) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CSRCreate with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in CSRCreateMultiError, or nil
// if none found.
func (m *CSRCreate) ValidateAll() error {
	return m.validate(true)
}

func (m *CSRCreate) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if m.GetApiVersion() != "assets.ubika.io/v1beta" {
		err := CSRCreateValidationError{
			field:  "ApiVersion",
			reason: "value must equal assets.ubika.io/v1beta",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if m.GetKind() != "CSRCreate" {
		err := CSRCreateValidationError{
			field:  "Kind",
			reason: "value must equal CSRCreate",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if m.GetMetadata() == nil {
		err := CSRCreateValidationError{
			field:  "Metadata",
			reason: "value is required",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if all {
		switch v := interface{}(m.GetMetadata()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CSRCreateValidationError{
					field:  "Metadata",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CSRCreateValidationError{
					field:  "Metadata",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetMetadata()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CSRCreateValidationError{
				field:  "Metadata",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if m.GetSpec() == nil {
		err := CSRCreateValidationError{
			field:  "Spec",
			reason: "value is required",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if all {
		switch v := interface{}(m.GetSpec()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CSRCreateValidationError{
					field:  "Spec",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CSRCreateValidationError{
					field:  "Spec",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetSpec()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CSRCreateValidationError{
				field:  "Spec",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return CSRCreateMultiError(errors)
	}

	return nil
}

// CSRCreateMultiError is an error wrapping multiple validation errors returned
// by CSRCreate.ValidateAll() if the designated constraints aren't met.
type CSRCreateMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CSRCreateMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CSRCreateMultiError) AllErrors() []error { return m }

// CSRCreateValidationError is the validation error returned by
// CSRCreate.Validate if the designated constraints aren't met.
type CSRCreateValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CSRCreateValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CSRCreateValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CSRCreateValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CSRCreateValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CSRCreateValidationError) ErrorName() string { return "CSRCreateValidationError" }

// Error satisfies the builtin error interface
func (e CSRCreateValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCSRCreate.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CSRCreateValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CSRCreateValidationError{}

// Validate checks the field values on CSRSpec with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *CSRSpec) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CSRSpec with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in CSRSpecMultiError, or nil if none found.
func (m *CSRSpec) ValidateAll() error {
	return m.validate(true)
}

func (m *CSRSpec) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Csr

	if len(errors) > 0 {
		return CSRSpecMultiError(errors)
	}

	return nil
}

// CSRSpecMultiError is an error wrapping multiple validation errors returned
// by CSRSpec.ValidateAll() if the designated constraints aren't met.
type CSRSpecMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CSRSpecMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CSRSpecMultiError) AllErrors() []error { return m }

// CSRSpecValidationError is the validation error returned by CSRSpec.Validate
// if the designated constraints aren't met.
type CSRSpecValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CSRSpecValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CSRSpecValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CSRSpecValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CSRSpecValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CSRSpecValidationError) ErrorName() string { return "CSRSpecValidationError" }

// Error satisfies the builtin error interface
func (e CSRSpecValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCSRSpec.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CSRSpecValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CSRSpecValidationError{}

// Validate checks the field values on CSR with the rules defined in the proto
// definition for this message. If any rules are violated, the first error
// encountered is returned, or nil if there are no violations.
func (m *CSR) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CSR with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in CSRMultiError, or nil if none found.
func (m *CSR) ValidateAll() error {
	return m.validate(true)
}

func (m *CSR) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if m.GetApiVersion() != "assets.ubika.io/v1beta" {
		err := CSRValidationError{
			field:  "ApiVersion",
			reason: "value must equal assets.ubika.io/v1beta",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if m.GetKind() != "CSR" {
		err := CSRValidationError{
			field:  "Kind",
			reason: "value must equal CSR",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if m.GetMetadata() == nil {
		err := CSRValidationError{
			field:  "Metadata",
			reason: "value is required",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if all {
		switch v := interface{}(m.GetMetadata()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CSRValidationError{
					field:  "Metadata",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CSRValidationError{
					field:  "Metadata",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetMetadata()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CSRValidationError{
				field:  "Metadata",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetStatus()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CSRValidationError{
					field:  "Status",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CSRValidationError{
					field:  "Status",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetStatus()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CSRValidationError{
				field:  "Status",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if m.GetSpec() == nil {
		err := CSRValidationError{
			field:  "Spec",
			reason: "value is required",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if all {
		switch v := interface{}(m.GetSpec()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CSRValidationError{
					field:  "Spec",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CSRValidationError{
					field:  "Spec",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetSpec()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CSRValidationError{
				field:  "Spec",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return CSRMultiError(errors)
	}

	return nil
}

// CSRMultiError is an error wrapping multiple validation errors returned by
// CSR.ValidateAll() if the designated constraints aren't met.
type CSRMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CSRMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CSRMultiError) AllErrors() []error { return m }

// CSRValidationError is the validation error returned by CSR.Validate if the
// designated constraints aren't met.
type CSRValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CSRValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CSRValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CSRValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CSRValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CSRValidationError) ErrorName() string { return "CSRValidationError" }

// Error satisfies the builtin error interface
func (e CSRValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCSR.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CSRValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CSRValidationError{}

// Validate checks the field values on CSRList with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *CSRList) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CSRList with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in CSRListMultiError, or nil if none found.
func (m *CSRList) ValidateAll() error {
	return m.validate(true)
}

func (m *CSRList) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if m.GetApiVersion() != "assets.ubika.io/v1beta" {
		err := CSRListValidationError{
			field:  "ApiVersion",
			reason: "value must equal assets.ubika.io/v1beta",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if m.GetKind() != "CSRList" {
		err := CSRListValidationError{
			field:  "Kind",
			reason: "value must equal CSRList",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if all {
		switch v := interface{}(m.GetMetadata()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CSRListValidationError{
					field:  "Metadata",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CSRListValidationError{
					field:  "Metadata",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetMetadata()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CSRListValidationError{
				field:  "Metadata",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	for idx, item := range m.GetItems() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, CSRListValidationError{
						field:  fmt.Sprintf("Items[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, CSRListValidationError{
						field:  fmt.Sprintf("Items[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return CSRListValidationError{
					field:  fmt.Sprintf("Items[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return CSRListMultiError(errors)
	}

	return nil
}

// CSRListMultiError is an error wrapping multiple validation errors returned
// by CSRList.ValidateAll() if the designated constraints aren't met.
type CSRListMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CSRListMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CSRListMultiError) AllErrors() []error { return m }

// CSRListValidationError is the validation error returned by CSRList.Validate
// if the designated constraints aren't met.
type CSRListValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CSRListValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CSRListValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CSRListValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CSRListValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CSRListValidationError) ErrorName() string { return "CSRListValidationError" }

// Error satisfies the builtin error interface
func (e CSRListValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCSRList.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CSRListValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CSRListValidationError{}

// Validate checks the field values on CSRFullSpec with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *CSRFullSpec) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CSRFullSpec with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in CSRFullSpecMultiError, or
// nil if none found.
func (m *CSRFullSpec) ValidateAll() error {
	return m.validate(true)
}

func (m *CSRFullSpec) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Csr

	// no validation rules for Key

	if len(errors) > 0 {
		return CSRFullSpecMultiError(errors)
	}

	return nil
}

// CSRFullSpecMultiError is an error wrapping multiple validation errors
// returned by CSRFullSpec.ValidateAll() if the designated constraints aren't met.
type CSRFullSpecMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CSRFullSpecMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CSRFullSpecMultiError) AllErrors() []error { return m }

// CSRFullSpecValidationError is the validation error returned by
// CSRFullSpec.Validate if the designated constraints aren't met.
type CSRFullSpecValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CSRFullSpecValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CSRFullSpecValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CSRFullSpecValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CSRFullSpecValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CSRFullSpecValidationError) ErrorName() string { return "CSRFullSpecValidationError" }

// Error satisfies the builtin error interface
func (e CSRFullSpecValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCSRFullSpec.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CSRFullSpecValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CSRFullSpecValidationError{}

// Validate checks the field values on CSRFull with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *CSRFull) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CSRFull with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in CSRFullMultiError, or nil if none found.
func (m *CSRFull) ValidateAll() error {
	return m.validate(true)
}

func (m *CSRFull) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if m.GetApiVersion() != "assets.ubika.io/v1beta" {
		err := CSRFullValidationError{
			field:  "ApiVersion",
			reason: "value must equal assets.ubika.io/v1beta",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if m.GetKind() != "CSRFull" {
		err := CSRFullValidationError{
			field:  "Kind",
			reason: "value must equal CSRFull",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if m.GetMetadata() == nil {
		err := CSRFullValidationError{
			field:  "Metadata",
			reason: "value is required",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if all {
		switch v := interface{}(m.GetMetadata()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CSRFullValidationError{
					field:  "Metadata",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CSRFullValidationError{
					field:  "Metadata",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetMetadata()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CSRFullValidationError{
				field:  "Metadata",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetStatus()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CSRFullValidationError{
					field:  "Status",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CSRFullValidationError{
					field:  "Status",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetStatus()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CSRFullValidationError{
				field:  "Status",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if m.GetSpec() == nil {
		err := CSRFullValidationError{
			field:  "Spec",
			reason: "value is required",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if all {
		switch v := interface{}(m.GetSpec()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CSRFullValidationError{
					field:  "Spec",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CSRFullValidationError{
					field:  "Spec",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetSpec()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CSRFullValidationError{
				field:  "Spec",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return CSRFullMultiError(errors)
	}

	return nil
}

// CSRFullMultiError is an error wrapping multiple validation errors returned
// by CSRFull.ValidateAll() if the designated constraints aren't met.
type CSRFullMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CSRFullMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CSRFullMultiError) AllErrors() []error { return m }

// CSRFullValidationError is the validation error returned by CSRFull.Validate
// if the designated constraints aren't met.
type CSRFullValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CSRFullValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CSRFullValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CSRFullValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CSRFullValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CSRFullValidationError) ErrorName() string { return "CSRFullValidationError" }

// Error satisfies the builtin error interface
func (e CSRFullValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCSRFull.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CSRFullValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CSRFullValidationError{}

// Validate checks the field values on CSRCertificateSpec with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *CSRCertificateSpec) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CSRCertificateSpec with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// CSRCertificateSpecMultiError, or nil if none found.
func (m *CSRCertificateSpec) ValidateAll() error {
	return m.validate(true)
}

func (m *CSRCertificateSpec) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if utf8.RuneCountInString(m.GetCsr()) > 63 {
		err := CSRCertificateSpecValidationError{
			field:  "Csr",
			reason: "value length must be at most 63 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if err := m._validateHostname(m.GetCsr()); err != nil {
		err = CSRCertificateSpecValidationError{
			field:  "Csr",
			reason: "value must be a valid hostname",
			cause:  err,
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for Certificate

	// no validation rules for Chain

	if len(errors) > 0 {
		return CSRCertificateSpecMultiError(errors)
	}

	return nil
}

func (m *CSRCertificateSpec) _validateHostname(host string) error {
	s := strings.ToLower(strings.TrimSuffix(host, "."))

	if len(host) > 253 {
		return errors.New("hostname cannot exceed 253 characters")
	}

	for _, part := range strings.Split(s, ".") {
		if l := len(part); l == 0 || l > 63 {
			return errors.New("hostname part must be non-empty and cannot exceed 63 characters")
		}

		if part[0] == '-' {
			return errors.New("hostname parts cannot begin with hyphens")
		}

		if part[len(part)-1] == '-' {
			return errors.New("hostname parts cannot end with hyphens")
		}

		for _, r := range part {
			if (r < 'a' || r > 'z') && (r < '0' || r > '9') && r != '-' {
				return fmt.Errorf("hostname parts can only contain alphanumeric characters or hyphens, got %q", string(r))
			}
		}
	}

	return nil
}

// CSRCertificateSpecMultiError is an error wrapping multiple validation errors
// returned by CSRCertificateSpec.ValidateAll() if the designated constraints
// aren't met.
type CSRCertificateSpecMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CSRCertificateSpecMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CSRCertificateSpecMultiError) AllErrors() []error { return m }

// CSRCertificateSpecValidationError is the validation error returned by
// CSRCertificateSpec.Validate if the designated constraints aren't met.
type CSRCertificateSpecValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CSRCertificateSpecValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CSRCertificateSpecValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CSRCertificateSpecValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CSRCertificateSpecValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CSRCertificateSpecValidationError) ErrorName() string {
	return "CSRCertificateSpecValidationError"
}

// Error satisfies the builtin error interface
func (e CSRCertificateSpecValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCSRCertificateSpec.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CSRCertificateSpecValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CSRCertificateSpecValidationError{}

// Validate checks the field values on CSRCertificate with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *CSRCertificate) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CSRCertificate with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in CSRCertificateMultiError,
// or nil if none found.
func (m *CSRCertificate) ValidateAll() error {
	return m.validate(true)
}

func (m *CSRCertificate) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if m.GetApiVersion() != "assets.ubika.io/v1beta" {
		err := CSRCertificateValidationError{
			field:  "ApiVersion",
			reason: "value must equal assets.ubika.io/v1beta",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if m.GetKind() != "CSRCertificate" {
		err := CSRCertificateValidationError{
			field:  "Kind",
			reason: "value must equal CSRCertificate",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if m.GetMetadata() == nil {
		err := CSRCertificateValidationError{
			field:  "Metadata",
			reason: "value is required",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if all {
		switch v := interface{}(m.GetMetadata()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CSRCertificateValidationError{
					field:  "Metadata",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CSRCertificateValidationError{
					field:  "Metadata",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetMetadata()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CSRCertificateValidationError{
				field:  "Metadata",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if m.GetSpec() == nil {
		err := CSRCertificateValidationError{
			field:  "Spec",
			reason: "value is required",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if all {
		switch v := interface{}(m.GetSpec()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CSRCertificateValidationError{
					field:  "Spec",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CSRCertificateValidationError{
					field:  "Spec",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetSpec()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CSRCertificateValidationError{
				field:  "Spec",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return CSRCertificateMultiError(errors)
	}

	return nil
}

// CSRCertificateMultiError is an error wrapping multiple validation errors
// returned by CSRCertificate.ValidateAll() if the designated constraints
// aren't met.
type CSRCertificateMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CSRCertificateMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CSRCertificateMultiError) AllErrors() []error { return m }

// CSRCertificateValidationError is the validation error returned by
// CSRCertificate.Validate if the designated constraints aren't met.
type CSRCertificateValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CSRCertificateValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CSRCertificateValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CSRCertificateValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CSRCertificateValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CSRCertificateValidationError) ErrorName() string { return "CSRCertificateValidationError" }

// Error satisfies the builtin error interface
func (e CSRCertificateValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCSRCertificate.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CSRCertificateValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CSRCertificateValidationError{}

// Validate checks the field values on TLSMaterialSpec with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *TLSMaterialSpec) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on TLSMaterialSpec with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// TLSMaterialSpecMultiError, or nil if none found.
func (m *TLSMaterialSpec) ValidateAll() error {
	return m.validate(true)
}

func (m *TLSMaterialSpec) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Certificate

	// no validation rules for Chain

	if len(errors) > 0 {
		return TLSMaterialSpecMultiError(errors)
	}

	return nil
}

// TLSMaterialSpecMultiError is an error wrapping multiple validation errors
// returned by TLSMaterialSpec.ValidateAll() if the designated constraints
// aren't met.
type TLSMaterialSpecMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m TLSMaterialSpecMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m TLSMaterialSpecMultiError) AllErrors() []error { return m }

// TLSMaterialSpecValidationError is the validation error returned by
// TLSMaterialSpec.Validate if the designated constraints aren't met.
type TLSMaterialSpecValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e TLSMaterialSpecValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e TLSMaterialSpecValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e TLSMaterialSpecValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e TLSMaterialSpecValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e TLSMaterialSpecValidationError) ErrorName() string { return "TLSMaterialSpecValidationError" }

// Error satisfies the builtin error interface
func (e TLSMaterialSpecValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sTLSMaterialSpec.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = TLSMaterialSpecValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = TLSMaterialSpecValidationError{}

// Validate checks the field values on TLSMaterial with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *TLSMaterial) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on TLSMaterial with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in TLSMaterialMultiError, or
// nil if none found.
func (m *TLSMaterial) ValidateAll() error {
	return m.validate(true)
}

func (m *TLSMaterial) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if m.GetApiVersion() != "assets.ubika.io/v1beta" {
		err := TLSMaterialValidationError{
			field:  "ApiVersion",
			reason: "value must equal assets.ubika.io/v1beta",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if m.GetKind() != "TLSMaterial" {
		err := TLSMaterialValidationError{
			field:  "Kind",
			reason: "value must equal TLSMaterial",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if m.GetMetadata() == nil {
		err := TLSMaterialValidationError{
			field:  "Metadata",
			reason: "value is required",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if all {
		switch v := interface{}(m.GetMetadata()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, TLSMaterialValidationError{
					field:  "Metadata",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, TLSMaterialValidationError{
					field:  "Metadata",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetMetadata()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return TLSMaterialValidationError{
				field:  "Metadata",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if m.GetSpec() == nil {
		err := TLSMaterialValidationError{
			field:  "Spec",
			reason: "value is required",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if all {
		switch v := interface{}(m.GetSpec()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, TLSMaterialValidationError{
					field:  "Spec",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, TLSMaterialValidationError{
					field:  "Spec",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetSpec()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return TLSMaterialValidationError{
				field:  "Spec",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetStatus()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, TLSMaterialValidationError{
					field:  "Status",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, TLSMaterialValidationError{
					field:  "Status",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetStatus()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return TLSMaterialValidationError{
				field:  "Status",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return TLSMaterialMultiError(errors)
	}

	return nil
}

// TLSMaterialMultiError is an error wrapping multiple validation errors
// returned by TLSMaterial.ValidateAll() if the designated constraints aren't met.
type TLSMaterialMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m TLSMaterialMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m TLSMaterialMultiError) AllErrors() []error { return m }

// TLSMaterialValidationError is the validation error returned by
// TLSMaterial.Validate if the designated constraints aren't met.
type TLSMaterialValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e TLSMaterialValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e TLSMaterialValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e TLSMaterialValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e TLSMaterialValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e TLSMaterialValidationError) ErrorName() string { return "TLSMaterialValidationError" }

// Error satisfies the builtin error interface
func (e TLSMaterialValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sTLSMaterial.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = TLSMaterialValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = TLSMaterialValidationError{}

// Validate checks the field values on TLSMaterialList with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *TLSMaterialList) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on TLSMaterialList with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// TLSMaterialListMultiError, or nil if none found.
func (m *TLSMaterialList) ValidateAll() error {
	return m.validate(true)
}

func (m *TLSMaterialList) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if m.GetApiVersion() != "assets.ubika.io/v1beta" {
		err := TLSMaterialListValidationError{
			field:  "ApiVersion",
			reason: "value must equal assets.ubika.io/v1beta",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if m.GetKind() != "TLSMaterial" {
		err := TLSMaterialListValidationError{
			field:  "Kind",
			reason: "value must equal TLSMaterial",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if all {
		switch v := interface{}(m.GetMetadata()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, TLSMaterialListValidationError{
					field:  "Metadata",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, TLSMaterialListValidationError{
					field:  "Metadata",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetMetadata()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return TLSMaterialListValidationError{
				field:  "Metadata",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	for idx, item := range m.GetItems() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, TLSMaterialListValidationError{
						field:  fmt.Sprintf("Items[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, TLSMaterialListValidationError{
						field:  fmt.Sprintf("Items[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return TLSMaterialListValidationError{
					field:  fmt.Sprintf("Items[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return TLSMaterialListMultiError(errors)
	}

	return nil
}

// TLSMaterialListMultiError is an error wrapping multiple validation errors
// returned by TLSMaterialList.ValidateAll() if the designated constraints
// aren't met.
type TLSMaterialListMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m TLSMaterialListMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m TLSMaterialListMultiError) AllErrors() []error { return m }

// TLSMaterialListValidationError is the validation error returned by
// TLSMaterialList.Validate if the designated constraints aren't met.
type TLSMaterialListValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e TLSMaterialListValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e TLSMaterialListValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e TLSMaterialListValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e TLSMaterialListValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e TLSMaterialListValidationError) ErrorName() string { return "TLSMaterialListValidationError" }

// Error satisfies the builtin error interface
func (e TLSMaterialListValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sTLSMaterialList.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = TLSMaterialListValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = TLSMaterialListValidationError{}

// Validate checks the field values on TLSMaterialStatus with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *TLSMaterialStatus) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on TLSMaterialStatus with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// TLSMaterialStatusMultiError, or nil if none found.
func (m *TLSMaterialStatus) ValidateAll() error {
	return m.validate(true)
}

func (m *TLSMaterialStatus) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Mode

	for idx, item := range m.GetHostnames() {
		_, _ = idx, item

		if err := m._validateHostname(item); err != nil {
			err = TLSMaterialStatusValidationError{
				field:  fmt.Sprintf("Hostnames[%v]", idx),
				reason: "value must be a valid hostname",
				cause:  err,
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

	}

	if all {
		switch v := interface{}(m.GetNotBefore()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, TLSMaterialStatusValidationError{
					field:  "NotBefore",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, TLSMaterialStatusValidationError{
					field:  "NotBefore",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetNotBefore()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return TLSMaterialStatusValidationError{
				field:  "NotBefore",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetNotAfter()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, TLSMaterialStatusValidationError{
					field:  "NotAfter",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, TLSMaterialStatusValidationError{
					field:  "NotAfter",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetNotAfter()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return TLSMaterialStatusValidationError{
				field:  "NotAfter",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for UsedBy

	// no validation rules for Issuer_CN

	// no validation rules for CN

	if len(errors) > 0 {
		return TLSMaterialStatusMultiError(errors)
	}

	return nil
}

func (m *TLSMaterialStatus) _validateHostname(host string) error {
	s := strings.ToLower(strings.TrimSuffix(host, "."))

	if len(host) > 253 {
		return errors.New("hostname cannot exceed 253 characters")
	}

	for _, part := range strings.Split(s, ".") {
		if l := len(part); l == 0 || l > 63 {
			return errors.New("hostname part must be non-empty and cannot exceed 63 characters")
		}

		if part[0] == '-' {
			return errors.New("hostname parts cannot begin with hyphens")
		}

		if part[len(part)-1] == '-' {
			return errors.New("hostname parts cannot end with hyphens")
		}

		for _, r := range part {
			if (r < 'a' || r > 'z') && (r < '0' || r > '9') && r != '-' {
				return fmt.Errorf("hostname parts can only contain alphanumeric characters or hyphens, got %q", string(r))
			}
		}
	}

	return nil
}

// TLSMaterialStatusMultiError is an error wrapping multiple validation errors
// returned by TLSMaterialStatus.ValidateAll() if the designated constraints
// aren't met.
type TLSMaterialStatusMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m TLSMaterialStatusMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m TLSMaterialStatusMultiError) AllErrors() []error { return m }

// TLSMaterialStatusValidationError is the validation error returned by
// TLSMaterialStatus.Validate if the designated constraints aren't met.
type TLSMaterialStatusValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e TLSMaterialStatusValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e TLSMaterialStatusValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e TLSMaterialStatusValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e TLSMaterialStatusValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e TLSMaterialStatusValidationError) ErrorName() string {
	return "TLSMaterialStatusValidationError"
}

// Error satisfies the builtin error interface
func (e TLSMaterialStatusValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sTLSMaterialStatus.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = TLSMaterialStatusValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = TLSMaterialStatusValidationError{}

// Validate checks the field values on TLSMaterialFullSpec with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *TLSMaterialFullSpec) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on TLSMaterialFullSpec with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// TLSMaterialFullSpecMultiError, or nil if none found.
func (m *TLSMaterialFullSpec) ValidateAll() error {
	return m.validate(true)
}

func (m *TLSMaterialFullSpec) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Certificate

	// no validation rules for Chain

	// no validation rules for Key

	if len(errors) > 0 {
		return TLSMaterialFullSpecMultiError(errors)
	}

	return nil
}

// TLSMaterialFullSpecMultiError is an error wrapping multiple validation
// errors returned by TLSMaterialFullSpec.ValidateAll() if the designated
// constraints aren't met.
type TLSMaterialFullSpecMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m TLSMaterialFullSpecMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m TLSMaterialFullSpecMultiError) AllErrors() []error { return m }

// TLSMaterialFullSpecValidationError is the validation error returned by
// TLSMaterialFullSpec.Validate if the designated constraints aren't met.
type TLSMaterialFullSpecValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e TLSMaterialFullSpecValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e TLSMaterialFullSpecValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e TLSMaterialFullSpecValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e TLSMaterialFullSpecValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e TLSMaterialFullSpecValidationError) ErrorName() string {
	return "TLSMaterialFullSpecValidationError"
}

// Error satisfies the builtin error interface
func (e TLSMaterialFullSpecValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sTLSMaterialFullSpec.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = TLSMaterialFullSpecValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = TLSMaterialFullSpecValidationError{}

// Validate checks the field values on TLSMaterialFull with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *TLSMaterialFull) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on TLSMaterialFull with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// TLSMaterialFullMultiError, or nil if none found.
func (m *TLSMaterialFull) ValidateAll() error {
	return m.validate(true)
}

func (m *TLSMaterialFull) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if m.GetApiVersion() != "assets.ubika.io/v1beta" {
		err := TLSMaterialFullValidationError{
			field:  "ApiVersion",
			reason: "value must equal assets.ubika.io/v1beta",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if m.GetKind() != "TLSMaterialFull" {
		err := TLSMaterialFullValidationError{
			field:  "Kind",
			reason: "value must equal TLSMaterialFull",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if m.GetMetadata() == nil {
		err := TLSMaterialFullValidationError{
			field:  "Metadata",
			reason: "value is required",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if all {
		switch v := interface{}(m.GetMetadata()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, TLSMaterialFullValidationError{
					field:  "Metadata",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, TLSMaterialFullValidationError{
					field:  "Metadata",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetMetadata()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return TLSMaterialFullValidationError{
				field:  "Metadata",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if m.GetSpec() == nil {
		err := TLSMaterialFullValidationError{
			field:  "Spec",
			reason: "value is required",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if all {
		switch v := interface{}(m.GetSpec()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, TLSMaterialFullValidationError{
					field:  "Spec",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, TLSMaterialFullValidationError{
					field:  "Spec",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetSpec()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return TLSMaterialFullValidationError{
				field:  "Spec",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetStatus()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, TLSMaterialFullValidationError{
					field:  "Status",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, TLSMaterialFullValidationError{
					field:  "Status",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetStatus()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return TLSMaterialFullValidationError{
				field:  "Status",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return TLSMaterialFullMultiError(errors)
	}

	return nil
}

// TLSMaterialFullMultiError is an error wrapping multiple validation errors
// returned by TLSMaterialFull.ValidateAll() if the designated constraints
// aren't met.
type TLSMaterialFullMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m TLSMaterialFullMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m TLSMaterialFullMultiError) AllErrors() []error { return m }

// TLSMaterialFullValidationError is the validation error returned by
// TLSMaterialFull.Validate if the designated constraints aren't met.
type TLSMaterialFullValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e TLSMaterialFullValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e TLSMaterialFullValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e TLSMaterialFullValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e TLSMaterialFullValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e TLSMaterialFullValidationError) ErrorName() string { return "TLSMaterialFullValidationError" }

// Error satisfies the builtin error interface
func (e TLSMaterialFullValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sTLSMaterialFull.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = TLSMaterialFullValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = TLSMaterialFullValidationError{}

// Validate checks the field values on TLSManualCreate with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *TLSManualCreate) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on TLSManualCreate with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// TLSManualCreateMultiError, or nil if none found.
func (m *TLSManualCreate) ValidateAll() error {
	return m.validate(true)
}

func (m *TLSManualCreate) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if m.GetApiVersion() != "assets.ubika.io/v1beta" {
		err := TLSManualCreateValidationError{
			field:  "ApiVersion",
			reason: "value must equal assets.ubika.io/v1beta",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if m.GetKind() != "TLSManualCreate" {
		err := TLSManualCreateValidationError{
			field:  "Kind",
			reason: "value must equal TLSManualCreate",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if m.GetMetadata() == nil {
		err := TLSManualCreateValidationError{
			field:  "Metadata",
			reason: "value is required",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if all {
		switch v := interface{}(m.GetMetadata()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, TLSManualCreateValidationError{
					field:  "Metadata",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, TLSManualCreateValidationError{
					field:  "Metadata",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetMetadata()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return TLSManualCreateValidationError{
				field:  "Metadata",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if m.GetSpec() == nil {
		err := TLSManualCreateValidationError{
			field:  "Spec",
			reason: "value is required",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if all {
		switch v := interface{}(m.GetSpec()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, TLSManualCreateValidationError{
					field:  "Spec",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, TLSManualCreateValidationError{
					field:  "Spec",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetSpec()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return TLSManualCreateValidationError{
				field:  "Spec",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return TLSManualCreateMultiError(errors)
	}

	return nil
}

// TLSManualCreateMultiError is an error wrapping multiple validation errors
// returned by TLSManualCreate.ValidateAll() if the designated constraints
// aren't met.
type TLSManualCreateMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m TLSManualCreateMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m TLSManualCreateMultiError) AllErrors() []error { return m }

// TLSManualCreateValidationError is the validation error returned by
// TLSManualCreate.Validate if the designated constraints aren't met.
type TLSManualCreateValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e TLSManualCreateValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e TLSManualCreateValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e TLSManualCreateValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e TLSManualCreateValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e TLSManualCreateValidationError) ErrorName() string { return "TLSManualCreateValidationError" }

// Error satisfies the builtin error interface
func (e TLSManualCreateValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sTLSManualCreate.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = TLSManualCreateValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = TLSManualCreateValidationError{}

// Validate checks the field values on TLSManualCreateSpec with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *TLSManualCreateSpec) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on TLSManualCreateSpec with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// TLSManualCreateSpecMultiError, or nil if none found.
func (m *TLSManualCreateSpec) ValidateAll() error {
	return m.validate(true)
}

func (m *TLSManualCreateSpec) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Certificate

	if m.GetChain() != "" {

	}

	// no validation rules for Key

	if len(errors) > 0 {
		return TLSManualCreateSpecMultiError(errors)
	}

	return nil
}

// TLSManualCreateSpecMultiError is an error wrapping multiple validation
// errors returned by TLSManualCreateSpec.ValidateAll() if the designated
// constraints aren't met.
type TLSManualCreateSpecMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m TLSManualCreateSpecMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m TLSManualCreateSpecMultiError) AllErrors() []error { return m }

// TLSManualCreateSpecValidationError is the validation error returned by
// TLSManualCreateSpec.Validate if the designated constraints aren't met.
type TLSManualCreateSpecValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e TLSManualCreateSpecValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e TLSManualCreateSpecValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e TLSManualCreateSpecValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e TLSManualCreateSpecValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e TLSManualCreateSpecValidationError) ErrorName() string {
	return "TLSManualCreateSpecValidationError"
}

// Error satisfies the builtin error interface
func (e TLSManualCreateSpecValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sTLSManualCreateSpec.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = TLSManualCreateSpecValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = TLSManualCreateSpecValidationError{}

// Validate checks the field values on TLSMaterialFullList with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *TLSMaterialFullList) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on TLSMaterialFullList with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// TLSMaterialFullListMultiError, or nil if none found.
func (m *TLSMaterialFullList) ValidateAll() error {
	return m.validate(true)
}

func (m *TLSMaterialFullList) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if m.GetApiVersion() != "assets.ubika.io/v1beta" {
		err := TLSMaterialFullListValidationError{
			field:  "ApiVersion",
			reason: "value must equal assets.ubika.io/v1beta",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if m.GetKind() != "TLSMaterialFullList" {
		err := TLSMaterialFullListValidationError{
			field:  "Kind",
			reason: "value must equal TLSMaterialFullList",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if all {
		switch v := interface{}(m.GetMetadata()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, TLSMaterialFullListValidationError{
					field:  "Metadata",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, TLSMaterialFullListValidationError{
					field:  "Metadata",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetMetadata()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return TLSMaterialFullListValidationError{
				field:  "Metadata",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	for idx, item := range m.GetItems() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, TLSMaterialFullListValidationError{
						field:  fmt.Sprintf("Items[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, TLSMaterialFullListValidationError{
						field:  fmt.Sprintf("Items[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return TLSMaterialFullListValidationError{
					field:  fmt.Sprintf("Items[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return TLSMaterialFullListMultiError(errors)
	}

	return nil
}

// TLSMaterialFullListMultiError is an error wrapping multiple validation
// errors returned by TLSMaterialFullList.ValidateAll() if the designated
// constraints aren't met.
type TLSMaterialFullListMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m TLSMaterialFullListMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m TLSMaterialFullListMultiError) AllErrors() []error { return m }

// TLSMaterialFullListValidationError is the validation error returned by
// TLSMaterialFullList.Validate if the designated constraints aren't met.
type TLSMaterialFullListValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e TLSMaterialFullListValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e TLSMaterialFullListValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e TLSMaterialFullListValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e TLSMaterialFullListValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e TLSMaterialFullListValidationError) ErrorName() string {
	return "TLSMaterialFullListValidationError"
}

// Error satisfies the builtin error interface
func (e TLSMaterialFullListValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sTLSMaterialFullList.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = TLSMaterialFullListValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = TLSMaterialFullListValidationError{}

// Validate checks the field values on TLSConfigurationSpec with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *TLSConfigurationSpec) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on TLSConfigurationSpec with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// TLSConfigurationSpecMultiError, or nil if none found.
func (m *TLSConfigurationSpec) ValidateAll() error {
	return m.validate(true)
}

func (m *TLSConfigurationSpec) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for ProtocolMin

	// no validation rules for ProtocolMax

	if len(errors) > 0 {
		return TLSConfigurationSpecMultiError(errors)
	}

	return nil
}

// TLSConfigurationSpecMultiError is an error wrapping multiple validation
// errors returned by TLSConfigurationSpec.ValidateAll() if the designated
// constraints aren't met.
type TLSConfigurationSpecMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m TLSConfigurationSpecMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m TLSConfigurationSpecMultiError) AllErrors() []error { return m }

// TLSConfigurationSpecValidationError is the validation error returned by
// TLSConfigurationSpec.Validate if the designated constraints aren't met.
type TLSConfigurationSpecValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e TLSConfigurationSpecValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e TLSConfigurationSpecValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e TLSConfigurationSpecValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e TLSConfigurationSpecValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e TLSConfigurationSpecValidationError) ErrorName() string {
	return "TLSConfigurationSpecValidationError"
}

// Error satisfies the builtin error interface
func (e TLSConfigurationSpecValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sTLSConfigurationSpec.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = TLSConfigurationSpecValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = TLSConfigurationSpecValidationError{}

// Validate checks the field values on TLSConfiguration with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *TLSConfiguration) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on TLSConfiguration with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// TLSConfigurationMultiError, or nil if none found.
func (m *TLSConfiguration) ValidateAll() error {
	return m.validate(true)
}

func (m *TLSConfiguration) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if m.GetApiVersion() != "assets.ubika.io/v1beta" {
		err := TLSConfigurationValidationError{
			field:  "ApiVersion",
			reason: "value must equal assets.ubika.io/v1beta",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if m.GetKind() != "TLSConfiguration" {
		err := TLSConfigurationValidationError{
			field:  "Kind",
			reason: "value must equal TLSConfiguration",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if m.GetMetadata() == nil {
		err := TLSConfigurationValidationError{
			field:  "Metadata",
			reason: "value is required",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if all {
		switch v := interface{}(m.GetMetadata()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, TLSConfigurationValidationError{
					field:  "Metadata",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, TLSConfigurationValidationError{
					field:  "Metadata",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetMetadata()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return TLSConfigurationValidationError{
				field:  "Metadata",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if m.GetSpec() == nil {
		err := TLSConfigurationValidationError{
			field:  "Spec",
			reason: "value is required",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if all {
		switch v := interface{}(m.GetSpec()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, TLSConfigurationValidationError{
					field:  "Spec",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, TLSConfigurationValidationError{
					field:  "Spec",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetSpec()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return TLSConfigurationValidationError{
				field:  "Spec",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return TLSConfigurationMultiError(errors)
	}

	return nil
}

// TLSConfigurationMultiError is an error wrapping multiple validation errors
// returned by TLSConfiguration.ValidateAll() if the designated constraints
// aren't met.
type TLSConfigurationMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m TLSConfigurationMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m TLSConfigurationMultiError) AllErrors() []error { return m }

// TLSConfigurationValidationError is the validation error returned by
// TLSConfiguration.Validate if the designated constraints aren't met.
type TLSConfigurationValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e TLSConfigurationValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e TLSConfigurationValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e TLSConfigurationValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e TLSConfigurationValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e TLSConfigurationValidationError) ErrorName() string { return "TLSConfigurationValidationError" }

// Error satisfies the builtin error interface
func (e TLSConfigurationValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sTLSConfiguration.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = TLSConfigurationValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = TLSConfigurationValidationError{}

// Validate checks the field values on TLSConfigurationList with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *TLSConfigurationList) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on TLSConfigurationList with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// TLSConfigurationListMultiError, or nil if none found.
func (m *TLSConfigurationList) ValidateAll() error {
	return m.validate(true)
}

func (m *TLSConfigurationList) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if m.GetApiVersion() != "assets.ubika.io/v1beta" {
		err := TLSConfigurationListValidationError{
			field:  "ApiVersion",
			reason: "value must equal assets.ubika.io/v1beta",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if m.GetKind() != "TLSConfigurationList" {
		err := TLSConfigurationListValidationError{
			field:  "Kind",
			reason: "value must equal TLSConfigurationList",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if all {
		switch v := interface{}(m.GetMetadata()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, TLSConfigurationListValidationError{
					field:  "Metadata",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, TLSConfigurationListValidationError{
					field:  "Metadata",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetMetadata()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return TLSConfigurationListValidationError{
				field:  "Metadata",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	for idx, item := range m.GetItems() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, TLSConfigurationListValidationError{
						field:  fmt.Sprintf("Items[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, TLSConfigurationListValidationError{
						field:  fmt.Sprintf("Items[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return TLSConfigurationListValidationError{
					field:  fmt.Sprintf("Items[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return TLSConfigurationListMultiError(errors)
	}

	return nil
}

// TLSConfigurationListMultiError is an error wrapping multiple validation
// errors returned by TLSConfigurationList.ValidateAll() if the designated
// constraints aren't met.
type TLSConfigurationListMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m TLSConfigurationListMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m TLSConfigurationListMultiError) AllErrors() []error { return m }

// TLSConfigurationListValidationError is the validation error returned by
// TLSConfigurationList.Validate if the designated constraints aren't met.
type TLSConfigurationListValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e TLSConfigurationListValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e TLSConfigurationListValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e TLSConfigurationListValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e TLSConfigurationListValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e TLSConfigurationListValidationError) ErrorName() string {
	return "TLSConfigurationListValidationError"
}

// Error satisfies the builtin error interface
func (e TLSConfigurationListValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sTLSConfigurationList.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = TLSConfigurationListValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = TLSConfigurationListValidationError{}

// Validate checks the field values on TLSConfigurationDefault with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *TLSConfigurationDefault) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on TLSConfigurationDefault with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// TLSConfigurationDefaultMultiError, or nil if none found.
func (m *TLSConfigurationDefault) ValidateAll() error {
	return m.validate(true)
}

func (m *TLSConfigurationDefault) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for ProtocolMinDefault

	// no validation rules for ProtocolMaxDefault

	if len(errors) > 0 {
		return TLSConfigurationDefaultMultiError(errors)
	}

	return nil
}

// TLSConfigurationDefaultMultiError is an error wrapping multiple validation
// errors returned by TLSConfigurationDefault.ValidateAll() if the designated
// constraints aren't met.
type TLSConfigurationDefaultMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m TLSConfigurationDefaultMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m TLSConfigurationDefaultMultiError) AllErrors() []error { return m }

// TLSConfigurationDefaultValidationError is the validation error returned by
// TLSConfigurationDefault.Validate if the designated constraints aren't met.
type TLSConfigurationDefaultValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e TLSConfigurationDefaultValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e TLSConfigurationDefaultValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e TLSConfigurationDefaultValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e TLSConfigurationDefaultValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e TLSConfigurationDefaultValidationError) ErrorName() string {
	return "TLSConfigurationDefaultValidationError"
}

// Error satisfies the builtin error interface
func (e TLSConfigurationDefaultValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sTLSConfigurationDefault.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = TLSConfigurationDefaultValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = TLSConfigurationDefaultValidationError{}

// Validate checks the field values on IPBlacklistSpec with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *IPBlacklistSpec) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on IPBlacklistSpec with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// IPBlacklistSpecMultiError, or nil if none found.
func (m *IPBlacklistSpec) ValidateAll() error {
	return m.validate(true)
}

func (m *IPBlacklistSpec) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetIpAddresses() {
		_, _ = idx, item

		if utf8.RuneCountInString(item) < 1 {
			err := IPBlacklistSpecValidationError{
				field:  fmt.Sprintf("IpAddresses[%v]", idx),
				reason: "value length must be at least 1 runes",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

	}

	if len(errors) > 0 {
		return IPBlacklistSpecMultiError(errors)
	}

	return nil
}

// IPBlacklistSpecMultiError is an error wrapping multiple validation errors
// returned by IPBlacklistSpec.ValidateAll() if the designated constraints
// aren't met.
type IPBlacklistSpecMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m IPBlacklistSpecMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m IPBlacklistSpecMultiError) AllErrors() []error { return m }

// IPBlacklistSpecValidationError is the validation error returned by
// IPBlacklistSpec.Validate if the designated constraints aren't met.
type IPBlacklistSpecValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e IPBlacklistSpecValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e IPBlacklistSpecValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e IPBlacklistSpecValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e IPBlacklistSpecValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e IPBlacklistSpecValidationError) ErrorName() string { return "IPBlacklistSpecValidationError" }

// Error satisfies the builtin error interface
func (e IPBlacklistSpecValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sIPBlacklistSpec.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = IPBlacklistSpecValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = IPBlacklistSpecValidationError{}

// Validate checks the field values on IPBlacklist with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *IPBlacklist) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on IPBlacklist with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in IPBlacklistMultiError, or
// nil if none found.
func (m *IPBlacklist) ValidateAll() error {
	return m.validate(true)
}

func (m *IPBlacklist) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if m.GetApiVersion() != "assets.ubika.io/v1beta" {
		err := IPBlacklistValidationError{
			field:  "ApiVersion",
			reason: "value must equal assets.ubika.io/v1beta",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if m.GetKind() != "IPBlacklist" {
		err := IPBlacklistValidationError{
			field:  "Kind",
			reason: "value must equal IPBlacklist",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if m.GetMetadata() == nil {
		err := IPBlacklistValidationError{
			field:  "Metadata",
			reason: "value is required",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if all {
		switch v := interface{}(m.GetMetadata()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, IPBlacklistValidationError{
					field:  "Metadata",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, IPBlacklistValidationError{
					field:  "Metadata",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetMetadata()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return IPBlacklistValidationError{
				field:  "Metadata",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if m.GetSpec() == nil {
		err := IPBlacklistValidationError{
			field:  "Spec",
			reason: "value is required",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if all {
		switch v := interface{}(m.GetSpec()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, IPBlacklistValidationError{
					field:  "Spec",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, IPBlacklistValidationError{
					field:  "Spec",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetSpec()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return IPBlacklistValidationError{
				field:  "Spec",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return IPBlacklistMultiError(errors)
	}

	return nil
}

// IPBlacklistMultiError is an error wrapping multiple validation errors
// returned by IPBlacklist.ValidateAll() if the designated constraints aren't met.
type IPBlacklistMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m IPBlacklistMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m IPBlacklistMultiError) AllErrors() []error { return m }

// IPBlacklistValidationError is the validation error returned by
// IPBlacklist.Validate if the designated constraints aren't met.
type IPBlacklistValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e IPBlacklistValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e IPBlacklistValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e IPBlacklistValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e IPBlacklistValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e IPBlacklistValidationError) ErrorName() string { return "IPBlacklistValidationError" }

// Error satisfies the builtin error interface
func (e IPBlacklistValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sIPBlacklist.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = IPBlacklistValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = IPBlacklistValidationError{}

// Validate checks the field values on IPBlacklistList with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *IPBlacklistList) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on IPBlacklistList with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// IPBlacklistListMultiError, or nil if none found.
func (m *IPBlacklistList) ValidateAll() error {
	return m.validate(true)
}

func (m *IPBlacklistList) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if m.GetApiVersion() != "assets.ubika.io/v1beta" {
		err := IPBlacklistListValidationError{
			field:  "ApiVersion",
			reason: "value must equal assets.ubika.io/v1beta",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if m.GetKind() != "IPBlacklistList" {
		err := IPBlacklistListValidationError{
			field:  "Kind",
			reason: "value must equal IPBlacklistList",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if all {
		switch v := interface{}(m.GetMetadata()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, IPBlacklistListValidationError{
					field:  "Metadata",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, IPBlacklistListValidationError{
					field:  "Metadata",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetMetadata()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return IPBlacklistListValidationError{
				field:  "Metadata",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	for idx, item := range m.GetItems() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, IPBlacklistListValidationError{
						field:  fmt.Sprintf("Items[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, IPBlacklistListValidationError{
						field:  fmt.Sprintf("Items[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return IPBlacklistListValidationError{
					field:  fmt.Sprintf("Items[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return IPBlacklistListMultiError(errors)
	}

	return nil
}

// IPBlacklistListMultiError is an error wrapping multiple validation errors
// returned by IPBlacklistList.ValidateAll() if the designated constraints
// aren't met.
type IPBlacklistListMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m IPBlacklistListMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m IPBlacklistListMultiError) AllErrors() []error { return m }

// IPBlacklistListValidationError is the validation error returned by
// IPBlacklistList.Validate if the designated constraints aren't met.
type IPBlacklistListValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e IPBlacklistListValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e IPBlacklistListValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e IPBlacklistListValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e IPBlacklistListValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e IPBlacklistListValidationError) ErrorName() string { return "IPBlacklistListValidationError" }

// Error satisfies the builtin error interface
func (e IPBlacklistListValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sIPBlacklistList.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = IPBlacklistListValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = IPBlacklistListValidationError{}

// Validate checks the field values on ExceptionProfileSpec_Rule with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ExceptionProfileSpec_Rule) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ExceptionProfileSpec_Rule with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ExceptionProfileSpec_RuleMultiError, or nil if none found.
func (m *ExceptionProfileSpec_Rule) ValidateAll() error {
	return m.validate(true)
}

func (m *ExceptionProfileSpec_Rule) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Name

	if len(errors) > 0 {
		return ExceptionProfileSpec_RuleMultiError(errors)
	}

	return nil
}

// ExceptionProfileSpec_RuleMultiError is an error wrapping multiple validation
// errors returned by ExceptionProfileSpec_Rule.ValidateAll() if the
// designated constraints aren't met.
type ExceptionProfileSpec_RuleMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ExceptionProfileSpec_RuleMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ExceptionProfileSpec_RuleMultiError) AllErrors() []error { return m }

// ExceptionProfileSpec_RuleValidationError is the validation error returned by
// ExceptionProfileSpec_Rule.Validate if the designated constraints aren't met.
type ExceptionProfileSpec_RuleValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ExceptionProfileSpec_RuleValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ExceptionProfileSpec_RuleValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ExceptionProfileSpec_RuleValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ExceptionProfileSpec_RuleValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ExceptionProfileSpec_RuleValidationError) ErrorName() string {
	return "ExceptionProfileSpec_RuleValidationError"
}

// Error satisfies the builtin error interface
func (e ExceptionProfileSpec_RuleValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sExceptionProfileSpec_Rule.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ExceptionProfileSpec_RuleValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ExceptionProfileSpec_RuleValidationError{}
