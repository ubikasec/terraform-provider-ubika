// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.3.0
// - protoc             v4.22.3
// source: lib/proto/assets.ubika.io/v1beta/asset_service.proto

package v1beta

import (
	context "context"
	v1beta "github.com/ubikasec/terraform-provider-ubika/internal/apis/meta/v1beta"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	emptypb "google.golang.org/protobuf/types/known/emptypb"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.32.0 or later.
const _ = grpc.SupportPackageIsVersion7

const (
	AssetSvc_List_FullMethodName         = "/assets.ubika.io.v1beta.AssetSvc/List"
	AssetSvc_Create_FullMethodName       = "/assets.ubika.io.v1beta.AssetSvc/Create"
	AssetSvc_Get_FullMethodName          = "/assets.ubika.io.v1beta.AssetSvc/Get"
	AssetSvc_Update_FullMethodName       = "/assets.ubika.io.v1beta.AssetSvc/Update"
	AssetSvc_Delete_FullMethodName       = "/assets.ubika.io.v1beta.AssetSvc/Delete"
	AssetSvc_Watch_FullMethodName        = "/assets.ubika.io.v1beta.AssetSvc/Watch"
	AssetSvc_UpdateStatus_FullMethodName = "/assets.ubika.io.v1beta.AssetSvc/UpdateStatus"
)

// AssetSvcClient is the client API for AssetSvc service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type AssetSvcClient interface {
	List(ctx context.Context, in *v1beta.ListOptions, opts ...grpc.CallOption) (*AssetList, error)
	Create(ctx context.Context, in *Asset, opts ...grpc.CallOption) (*Asset, error)
	Get(ctx context.Context, in *v1beta.GetOptions, opts ...grpc.CallOption) (*Asset, error)
	Update(ctx context.Context, in *Asset, opts ...grpc.CallOption) (*Asset, error)
	Delete(ctx context.Context, in *v1beta.DeleteOptions, opts ...grpc.CallOption) (*Asset, error)
	Watch(ctx context.Context, in *v1beta.WatchOptions, opts ...grpc.CallOption) (AssetSvc_WatchClient, error)
	UpdateStatus(ctx context.Context, in *Asset, opts ...grpc.CallOption) (*Asset, error)
}

type assetSvcClient struct {
	cc grpc.ClientConnInterface
}

func NewAssetSvcClient(cc grpc.ClientConnInterface) AssetSvcClient {
	return &assetSvcClient{cc}
}

func (c *assetSvcClient) List(ctx context.Context, in *v1beta.ListOptions, opts ...grpc.CallOption) (*AssetList, error) {
	out := new(AssetList)
	err := c.cc.Invoke(ctx, AssetSvc_List_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *assetSvcClient) Create(ctx context.Context, in *Asset, opts ...grpc.CallOption) (*Asset, error) {
	out := new(Asset)
	err := c.cc.Invoke(ctx, AssetSvc_Create_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *assetSvcClient) Get(ctx context.Context, in *v1beta.GetOptions, opts ...grpc.CallOption) (*Asset, error) {
	out := new(Asset)
	err := c.cc.Invoke(ctx, AssetSvc_Get_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *assetSvcClient) Update(ctx context.Context, in *Asset, opts ...grpc.CallOption) (*Asset, error) {
	out := new(Asset)
	err := c.cc.Invoke(ctx, AssetSvc_Update_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *assetSvcClient) Delete(ctx context.Context, in *v1beta.DeleteOptions, opts ...grpc.CallOption) (*Asset, error) {
	out := new(Asset)
	err := c.cc.Invoke(ctx, AssetSvc_Delete_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *assetSvcClient) Watch(ctx context.Context, in *v1beta.WatchOptions, opts ...grpc.CallOption) (AssetSvc_WatchClient, error) {
	stream, err := c.cc.NewStream(ctx, &AssetSvc_ServiceDesc.Streams[0], AssetSvc_Watch_FullMethodName, opts...)
	if err != nil {
		return nil, err
	}
	x := &assetSvcWatchClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type AssetSvc_WatchClient interface {
	Recv() (*v1beta.WatchEvent, error)
	grpc.ClientStream
}

type assetSvcWatchClient struct {
	grpc.ClientStream
}

func (x *assetSvcWatchClient) Recv() (*v1beta.WatchEvent, error) {
	m := new(v1beta.WatchEvent)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *assetSvcClient) UpdateStatus(ctx context.Context, in *Asset, opts ...grpc.CallOption) (*Asset, error) {
	out := new(Asset)
	err := c.cc.Invoke(ctx, AssetSvc_UpdateStatus_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// AssetSvcServer is the server API for AssetSvc service.
// All implementations must embed UnimplementedAssetSvcServer
// for forward compatibility
type AssetSvcServer interface {
	List(context.Context, *v1beta.ListOptions) (*AssetList, error)
	Create(context.Context, *Asset) (*Asset, error)
	Get(context.Context, *v1beta.GetOptions) (*Asset, error)
	Update(context.Context, *Asset) (*Asset, error)
	Delete(context.Context, *v1beta.DeleteOptions) (*Asset, error)
	Watch(*v1beta.WatchOptions, AssetSvc_WatchServer) error
	UpdateStatus(context.Context, *Asset) (*Asset, error)
	mustEmbedUnimplementedAssetSvcServer()
}

// UnimplementedAssetSvcServer must be embedded to have forward compatible implementations.
type UnimplementedAssetSvcServer struct {
}

func (UnimplementedAssetSvcServer) List(context.Context, *v1beta.ListOptions) (*AssetList, error) {
	return nil, status.Errorf(codes.Unimplemented, "method List not implemented")
}
func (UnimplementedAssetSvcServer) Create(context.Context, *Asset) (*Asset, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Create not implemented")
}
func (UnimplementedAssetSvcServer) Get(context.Context, *v1beta.GetOptions) (*Asset, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Get not implemented")
}
func (UnimplementedAssetSvcServer) Update(context.Context, *Asset) (*Asset, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Update not implemented")
}
func (UnimplementedAssetSvcServer) Delete(context.Context, *v1beta.DeleteOptions) (*Asset, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Delete not implemented")
}
func (UnimplementedAssetSvcServer) Watch(*v1beta.WatchOptions, AssetSvc_WatchServer) error {
	return status.Errorf(codes.Unimplemented, "method Watch not implemented")
}
func (UnimplementedAssetSvcServer) UpdateStatus(context.Context, *Asset) (*Asset, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateStatus not implemented")
}
func (UnimplementedAssetSvcServer) mustEmbedUnimplementedAssetSvcServer() {}

// UnsafeAssetSvcServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to AssetSvcServer will
// result in compilation errors.
type UnsafeAssetSvcServer interface {
	mustEmbedUnimplementedAssetSvcServer()
}

func RegisterAssetSvcServer(s grpc.ServiceRegistrar, srv AssetSvcServer) {
	s.RegisterService(&AssetSvc_ServiceDesc, srv)
}

func _AssetSvc_List_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(v1beta.ListOptions)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AssetSvcServer).List(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: AssetSvc_List_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AssetSvcServer).List(ctx, req.(*v1beta.ListOptions))
	}
	return interceptor(ctx, in, info, handler)
}

func _AssetSvc_Create_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Asset)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AssetSvcServer).Create(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: AssetSvc_Create_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AssetSvcServer).Create(ctx, req.(*Asset))
	}
	return interceptor(ctx, in, info, handler)
}

func _AssetSvc_Get_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(v1beta.GetOptions)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AssetSvcServer).Get(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: AssetSvc_Get_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AssetSvcServer).Get(ctx, req.(*v1beta.GetOptions))
	}
	return interceptor(ctx, in, info, handler)
}

func _AssetSvc_Update_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Asset)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AssetSvcServer).Update(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: AssetSvc_Update_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AssetSvcServer).Update(ctx, req.(*Asset))
	}
	return interceptor(ctx, in, info, handler)
}

func _AssetSvc_Delete_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(v1beta.DeleteOptions)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AssetSvcServer).Delete(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: AssetSvc_Delete_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AssetSvcServer).Delete(ctx, req.(*v1beta.DeleteOptions))
	}
	return interceptor(ctx, in, info, handler)
}

func _AssetSvc_Watch_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(v1beta.WatchOptions)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(AssetSvcServer).Watch(m, &assetSvcWatchServer{stream})
}

type AssetSvc_WatchServer interface {
	Send(*v1beta.WatchEvent) error
	grpc.ServerStream
}

type assetSvcWatchServer struct {
	grpc.ServerStream
}

func (x *assetSvcWatchServer) Send(m *v1beta.WatchEvent) error {
	return x.ServerStream.SendMsg(m)
}

func _AssetSvc_UpdateStatus_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Asset)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AssetSvcServer).UpdateStatus(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: AssetSvc_UpdateStatus_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AssetSvcServer).UpdateStatus(ctx, req.(*Asset))
	}
	return interceptor(ctx, in, info, handler)
}

// AssetSvc_ServiceDesc is the grpc.ServiceDesc for AssetSvc service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var AssetSvc_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "assets.ubika.io.v1beta.AssetSvc",
	HandlerType: (*AssetSvcServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "List",
			Handler:    _AssetSvc_List_Handler,
		},
		{
			MethodName: "Create",
			Handler:    _AssetSvc_Create_Handler,
		},
		{
			MethodName: "Get",
			Handler:    _AssetSvc_Get_Handler,
		},
		{
			MethodName: "Update",
			Handler:    _AssetSvc_Update_Handler,
		},
		{
			MethodName: "Delete",
			Handler:    _AssetSvc_Delete_Handler,
		},
		{
			MethodName: "UpdateStatus",
			Handler:    _AssetSvc_UpdateStatus_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "Watch",
			Handler:       _AssetSvc_Watch_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "lib/proto/assets.ubika.io/v1beta/asset_service.proto",
}

const (
	WorkflowSvc_List_FullMethodName   = "/assets.ubika.io.v1beta.WorkflowSvc/List"
	WorkflowSvc_Create_FullMethodName = "/assets.ubika.io.v1beta.WorkflowSvc/Create"
	WorkflowSvc_Get_FullMethodName    = "/assets.ubika.io.v1beta.WorkflowSvc/Get"
	WorkflowSvc_Update_FullMethodName = "/assets.ubika.io.v1beta.WorkflowSvc/Update"
	WorkflowSvc_Delete_FullMethodName = "/assets.ubika.io.v1beta.WorkflowSvc/Delete"
	WorkflowSvc_Watch_FullMethodName  = "/assets.ubika.io.v1beta.WorkflowSvc/Watch"
)

// WorkflowSvcClient is the client API for WorkflowSvc service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type WorkflowSvcClient interface {
	List(ctx context.Context, in *v1beta.ListOptions, opts ...grpc.CallOption) (*WorkflowList, error)
	Create(ctx context.Context, in *Workflow, opts ...grpc.CallOption) (*Workflow, error)
	Get(ctx context.Context, in *v1beta.GetOptions, opts ...grpc.CallOption) (*Workflow, error)
	Update(ctx context.Context, in *Workflow, opts ...grpc.CallOption) (*Workflow, error)
	Delete(ctx context.Context, in *v1beta.DeleteOptions, opts ...grpc.CallOption) (*Workflow, error)
	Watch(ctx context.Context, in *v1beta.WatchOptions, opts ...grpc.CallOption) (WorkflowSvc_WatchClient, error)
}

type workflowSvcClient struct {
	cc grpc.ClientConnInterface
}

func NewWorkflowSvcClient(cc grpc.ClientConnInterface) WorkflowSvcClient {
	return &workflowSvcClient{cc}
}

func (c *workflowSvcClient) List(ctx context.Context, in *v1beta.ListOptions, opts ...grpc.CallOption) (*WorkflowList, error) {
	out := new(WorkflowList)
	err := c.cc.Invoke(ctx, WorkflowSvc_List_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *workflowSvcClient) Create(ctx context.Context, in *Workflow, opts ...grpc.CallOption) (*Workflow, error) {
	out := new(Workflow)
	err := c.cc.Invoke(ctx, WorkflowSvc_Create_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *workflowSvcClient) Get(ctx context.Context, in *v1beta.GetOptions, opts ...grpc.CallOption) (*Workflow, error) {
	out := new(Workflow)
	err := c.cc.Invoke(ctx, WorkflowSvc_Get_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *workflowSvcClient) Update(ctx context.Context, in *Workflow, opts ...grpc.CallOption) (*Workflow, error) {
	out := new(Workflow)
	err := c.cc.Invoke(ctx, WorkflowSvc_Update_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *workflowSvcClient) Delete(ctx context.Context, in *v1beta.DeleteOptions, opts ...grpc.CallOption) (*Workflow, error) {
	out := new(Workflow)
	err := c.cc.Invoke(ctx, WorkflowSvc_Delete_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *workflowSvcClient) Watch(ctx context.Context, in *v1beta.WatchOptions, opts ...grpc.CallOption) (WorkflowSvc_WatchClient, error) {
	stream, err := c.cc.NewStream(ctx, &WorkflowSvc_ServiceDesc.Streams[0], WorkflowSvc_Watch_FullMethodName, opts...)
	if err != nil {
		return nil, err
	}
	x := &workflowSvcWatchClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type WorkflowSvc_WatchClient interface {
	Recv() (*v1beta.WatchEvent, error)
	grpc.ClientStream
}

type workflowSvcWatchClient struct {
	grpc.ClientStream
}

func (x *workflowSvcWatchClient) Recv() (*v1beta.WatchEvent, error) {
	m := new(v1beta.WatchEvent)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

// WorkflowSvcServer is the server API for WorkflowSvc service.
// All implementations must embed UnimplementedWorkflowSvcServer
// for forward compatibility
type WorkflowSvcServer interface {
	List(context.Context, *v1beta.ListOptions) (*WorkflowList, error)
	Create(context.Context, *Workflow) (*Workflow, error)
	Get(context.Context, *v1beta.GetOptions) (*Workflow, error)
	Update(context.Context, *Workflow) (*Workflow, error)
	Delete(context.Context, *v1beta.DeleteOptions) (*Workflow, error)
	Watch(*v1beta.WatchOptions, WorkflowSvc_WatchServer) error
	mustEmbedUnimplementedWorkflowSvcServer()
}

// UnimplementedWorkflowSvcServer must be embedded to have forward compatible implementations.
type UnimplementedWorkflowSvcServer struct {
}

func (UnimplementedWorkflowSvcServer) List(context.Context, *v1beta.ListOptions) (*WorkflowList, error) {
	return nil, status.Errorf(codes.Unimplemented, "method List not implemented")
}
func (UnimplementedWorkflowSvcServer) Create(context.Context, *Workflow) (*Workflow, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Create not implemented")
}
func (UnimplementedWorkflowSvcServer) Get(context.Context, *v1beta.GetOptions) (*Workflow, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Get not implemented")
}
func (UnimplementedWorkflowSvcServer) Update(context.Context, *Workflow) (*Workflow, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Update not implemented")
}
func (UnimplementedWorkflowSvcServer) Delete(context.Context, *v1beta.DeleteOptions) (*Workflow, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Delete not implemented")
}
func (UnimplementedWorkflowSvcServer) Watch(*v1beta.WatchOptions, WorkflowSvc_WatchServer) error {
	return status.Errorf(codes.Unimplemented, "method Watch not implemented")
}
func (UnimplementedWorkflowSvcServer) mustEmbedUnimplementedWorkflowSvcServer() {}

// UnsafeWorkflowSvcServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to WorkflowSvcServer will
// result in compilation errors.
type UnsafeWorkflowSvcServer interface {
	mustEmbedUnimplementedWorkflowSvcServer()
}

func RegisterWorkflowSvcServer(s grpc.ServiceRegistrar, srv WorkflowSvcServer) {
	s.RegisterService(&WorkflowSvc_ServiceDesc, srv)
}

func _WorkflowSvc_List_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(v1beta.ListOptions)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WorkflowSvcServer).List(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: WorkflowSvc_List_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WorkflowSvcServer).List(ctx, req.(*v1beta.ListOptions))
	}
	return interceptor(ctx, in, info, handler)
}

func _WorkflowSvc_Create_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Workflow)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WorkflowSvcServer).Create(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: WorkflowSvc_Create_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WorkflowSvcServer).Create(ctx, req.(*Workflow))
	}
	return interceptor(ctx, in, info, handler)
}

func _WorkflowSvc_Get_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(v1beta.GetOptions)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WorkflowSvcServer).Get(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: WorkflowSvc_Get_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WorkflowSvcServer).Get(ctx, req.(*v1beta.GetOptions))
	}
	return interceptor(ctx, in, info, handler)
}

func _WorkflowSvc_Update_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Workflow)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WorkflowSvcServer).Update(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: WorkflowSvc_Update_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WorkflowSvcServer).Update(ctx, req.(*Workflow))
	}
	return interceptor(ctx, in, info, handler)
}

func _WorkflowSvc_Delete_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(v1beta.DeleteOptions)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WorkflowSvcServer).Delete(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: WorkflowSvc_Delete_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WorkflowSvcServer).Delete(ctx, req.(*v1beta.DeleteOptions))
	}
	return interceptor(ctx, in, info, handler)
}

func _WorkflowSvc_Watch_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(v1beta.WatchOptions)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(WorkflowSvcServer).Watch(m, &workflowSvcWatchServer{stream})
}

type WorkflowSvc_WatchServer interface {
	Send(*v1beta.WatchEvent) error
	grpc.ServerStream
}

type workflowSvcWatchServer struct {
	grpc.ServerStream
}

func (x *workflowSvcWatchServer) Send(m *v1beta.WatchEvent) error {
	return x.ServerStream.SendMsg(m)
}

// WorkflowSvc_ServiceDesc is the grpc.ServiceDesc for WorkflowSvc service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var WorkflowSvc_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "assets.ubika.io.v1beta.WorkflowSvc",
	HandlerType: (*WorkflowSvcServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "List",
			Handler:    _WorkflowSvc_List_Handler,
		},
		{
			MethodName: "Create",
			Handler:    _WorkflowSvc_Create_Handler,
		},
		{
			MethodName: "Get",
			Handler:    _WorkflowSvc_Get_Handler,
		},
		{
			MethodName: "Update",
			Handler:    _WorkflowSvc_Update_Handler,
		},
		{
			MethodName: "Delete",
			Handler:    _WorkflowSvc_Delete_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "Watch",
			Handler:       _WorkflowSvc_Watch_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "lib/proto/assets.ubika.io/v1beta/asset_service.proto",
}

const (
	OpenAPISvc_List_FullMethodName   = "/assets.ubika.io.v1beta.OpenAPISvc/List"
	OpenAPISvc_Create_FullMethodName = "/assets.ubika.io.v1beta.OpenAPISvc/Create"
	OpenAPISvc_Get_FullMethodName    = "/assets.ubika.io.v1beta.OpenAPISvc/Get"
	OpenAPISvc_Update_FullMethodName = "/assets.ubika.io.v1beta.OpenAPISvc/Update"
	OpenAPISvc_Delete_FullMethodName = "/assets.ubika.io.v1beta.OpenAPISvc/Delete"
	OpenAPISvc_Watch_FullMethodName  = "/assets.ubika.io.v1beta.OpenAPISvc/Watch"
)

// OpenAPISvcClient is the client API for OpenAPISvc service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type OpenAPISvcClient interface {
	List(ctx context.Context, in *v1beta.ListOptions, opts ...grpc.CallOption) (*OpenAPIList, error)
	Create(ctx context.Context, in *OpenAPI, opts ...grpc.CallOption) (*OpenAPI, error)
	Get(ctx context.Context, in *v1beta.GetOptions, opts ...grpc.CallOption) (*OpenAPI, error)
	Update(ctx context.Context, in *OpenAPI, opts ...grpc.CallOption) (*OpenAPI, error)
	Delete(ctx context.Context, in *v1beta.DeleteOptions, opts ...grpc.CallOption) (*OpenAPI, error)
	Watch(ctx context.Context, in *v1beta.WatchOptions, opts ...grpc.CallOption) (OpenAPISvc_WatchClient, error)
}

type openAPISvcClient struct {
	cc grpc.ClientConnInterface
}

func NewOpenAPISvcClient(cc grpc.ClientConnInterface) OpenAPISvcClient {
	return &openAPISvcClient{cc}
}

func (c *openAPISvcClient) List(ctx context.Context, in *v1beta.ListOptions, opts ...grpc.CallOption) (*OpenAPIList, error) {
	out := new(OpenAPIList)
	err := c.cc.Invoke(ctx, OpenAPISvc_List_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *openAPISvcClient) Create(ctx context.Context, in *OpenAPI, opts ...grpc.CallOption) (*OpenAPI, error) {
	out := new(OpenAPI)
	err := c.cc.Invoke(ctx, OpenAPISvc_Create_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *openAPISvcClient) Get(ctx context.Context, in *v1beta.GetOptions, opts ...grpc.CallOption) (*OpenAPI, error) {
	out := new(OpenAPI)
	err := c.cc.Invoke(ctx, OpenAPISvc_Get_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *openAPISvcClient) Update(ctx context.Context, in *OpenAPI, opts ...grpc.CallOption) (*OpenAPI, error) {
	out := new(OpenAPI)
	err := c.cc.Invoke(ctx, OpenAPISvc_Update_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *openAPISvcClient) Delete(ctx context.Context, in *v1beta.DeleteOptions, opts ...grpc.CallOption) (*OpenAPI, error) {
	out := new(OpenAPI)
	err := c.cc.Invoke(ctx, OpenAPISvc_Delete_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *openAPISvcClient) Watch(ctx context.Context, in *v1beta.WatchOptions, opts ...grpc.CallOption) (OpenAPISvc_WatchClient, error) {
	stream, err := c.cc.NewStream(ctx, &OpenAPISvc_ServiceDesc.Streams[0], OpenAPISvc_Watch_FullMethodName, opts...)
	if err != nil {
		return nil, err
	}
	x := &openAPISvcWatchClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type OpenAPISvc_WatchClient interface {
	Recv() (*v1beta.WatchEvent, error)
	grpc.ClientStream
}

type openAPISvcWatchClient struct {
	grpc.ClientStream
}

func (x *openAPISvcWatchClient) Recv() (*v1beta.WatchEvent, error) {
	m := new(v1beta.WatchEvent)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

// OpenAPISvcServer is the server API for OpenAPISvc service.
// All implementations must embed UnimplementedOpenAPISvcServer
// for forward compatibility
type OpenAPISvcServer interface {
	List(context.Context, *v1beta.ListOptions) (*OpenAPIList, error)
	Create(context.Context, *OpenAPI) (*OpenAPI, error)
	Get(context.Context, *v1beta.GetOptions) (*OpenAPI, error)
	Update(context.Context, *OpenAPI) (*OpenAPI, error)
	Delete(context.Context, *v1beta.DeleteOptions) (*OpenAPI, error)
	Watch(*v1beta.WatchOptions, OpenAPISvc_WatchServer) error
	mustEmbedUnimplementedOpenAPISvcServer()
}

// UnimplementedOpenAPISvcServer must be embedded to have forward compatible implementations.
type UnimplementedOpenAPISvcServer struct {
}

func (UnimplementedOpenAPISvcServer) List(context.Context, *v1beta.ListOptions) (*OpenAPIList, error) {
	return nil, status.Errorf(codes.Unimplemented, "method List not implemented")
}
func (UnimplementedOpenAPISvcServer) Create(context.Context, *OpenAPI) (*OpenAPI, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Create not implemented")
}
func (UnimplementedOpenAPISvcServer) Get(context.Context, *v1beta.GetOptions) (*OpenAPI, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Get not implemented")
}
func (UnimplementedOpenAPISvcServer) Update(context.Context, *OpenAPI) (*OpenAPI, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Update not implemented")
}
func (UnimplementedOpenAPISvcServer) Delete(context.Context, *v1beta.DeleteOptions) (*OpenAPI, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Delete not implemented")
}
func (UnimplementedOpenAPISvcServer) Watch(*v1beta.WatchOptions, OpenAPISvc_WatchServer) error {
	return status.Errorf(codes.Unimplemented, "method Watch not implemented")
}
func (UnimplementedOpenAPISvcServer) mustEmbedUnimplementedOpenAPISvcServer() {}

// UnsafeOpenAPISvcServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to OpenAPISvcServer will
// result in compilation errors.
type UnsafeOpenAPISvcServer interface {
	mustEmbedUnimplementedOpenAPISvcServer()
}

func RegisterOpenAPISvcServer(s grpc.ServiceRegistrar, srv OpenAPISvcServer) {
	s.RegisterService(&OpenAPISvc_ServiceDesc, srv)
}

func _OpenAPISvc_List_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(v1beta.ListOptions)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(OpenAPISvcServer).List(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: OpenAPISvc_List_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(OpenAPISvcServer).List(ctx, req.(*v1beta.ListOptions))
	}
	return interceptor(ctx, in, info, handler)
}

func _OpenAPISvc_Create_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(OpenAPI)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(OpenAPISvcServer).Create(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: OpenAPISvc_Create_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(OpenAPISvcServer).Create(ctx, req.(*OpenAPI))
	}
	return interceptor(ctx, in, info, handler)
}

func _OpenAPISvc_Get_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(v1beta.GetOptions)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(OpenAPISvcServer).Get(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: OpenAPISvc_Get_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(OpenAPISvcServer).Get(ctx, req.(*v1beta.GetOptions))
	}
	return interceptor(ctx, in, info, handler)
}

func _OpenAPISvc_Update_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(OpenAPI)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(OpenAPISvcServer).Update(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: OpenAPISvc_Update_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(OpenAPISvcServer).Update(ctx, req.(*OpenAPI))
	}
	return interceptor(ctx, in, info, handler)
}

func _OpenAPISvc_Delete_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(v1beta.DeleteOptions)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(OpenAPISvcServer).Delete(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: OpenAPISvc_Delete_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(OpenAPISvcServer).Delete(ctx, req.(*v1beta.DeleteOptions))
	}
	return interceptor(ctx, in, info, handler)
}

func _OpenAPISvc_Watch_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(v1beta.WatchOptions)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(OpenAPISvcServer).Watch(m, &openAPISvcWatchServer{stream})
}

type OpenAPISvc_WatchServer interface {
	Send(*v1beta.WatchEvent) error
	grpc.ServerStream
}

type openAPISvcWatchServer struct {
	grpc.ServerStream
}

func (x *openAPISvcWatchServer) Send(m *v1beta.WatchEvent) error {
	return x.ServerStream.SendMsg(m)
}

// OpenAPISvc_ServiceDesc is the grpc.ServiceDesc for OpenAPISvc service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var OpenAPISvc_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "assets.ubika.io.v1beta.OpenAPISvc",
	HandlerType: (*OpenAPISvcServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "List",
			Handler:    _OpenAPISvc_List_Handler,
		},
		{
			MethodName: "Create",
			Handler:    _OpenAPISvc_Create_Handler,
		},
		{
			MethodName: "Get",
			Handler:    _OpenAPISvc_Get_Handler,
		},
		{
			MethodName: "Update",
			Handler:    _OpenAPISvc_Update_Handler,
		},
		{
			MethodName: "Delete",
			Handler:    _OpenAPISvc_Delete_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "Watch",
			Handler:       _OpenAPISvc_Watch_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "lib/proto/assets.ubika.io/v1beta/asset_service.proto",
}

const (
	ExceptionProfileSvc_List_FullMethodName   = "/assets.ubika.io.v1beta.ExceptionProfileSvc/List"
	ExceptionProfileSvc_Create_FullMethodName = "/assets.ubika.io.v1beta.ExceptionProfileSvc/Create"
	ExceptionProfileSvc_Get_FullMethodName    = "/assets.ubika.io.v1beta.ExceptionProfileSvc/Get"
	ExceptionProfileSvc_Update_FullMethodName = "/assets.ubika.io.v1beta.ExceptionProfileSvc/Update"
	ExceptionProfileSvc_Delete_FullMethodName = "/assets.ubika.io.v1beta.ExceptionProfileSvc/Delete"
	ExceptionProfileSvc_Watch_FullMethodName  = "/assets.ubika.io.v1beta.ExceptionProfileSvc/Watch"
)

// ExceptionProfileSvcClient is the client API for ExceptionProfileSvc service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type ExceptionProfileSvcClient interface {
	List(ctx context.Context, in *v1beta.ListOptions, opts ...grpc.CallOption) (*ExceptionProfileList, error)
	Create(ctx context.Context, in *ExceptionProfile, opts ...grpc.CallOption) (*ExceptionProfile, error)
	Get(ctx context.Context, in *v1beta.GetOptions, opts ...grpc.CallOption) (*ExceptionProfile, error)
	Update(ctx context.Context, in *ExceptionProfile, opts ...grpc.CallOption) (*ExceptionProfile, error)
	Delete(ctx context.Context, in *v1beta.DeleteOptions, opts ...grpc.CallOption) (*ExceptionProfile, error)
	Watch(ctx context.Context, in *v1beta.WatchOptions, opts ...grpc.CallOption) (ExceptionProfileSvc_WatchClient, error)
}

type exceptionProfileSvcClient struct {
	cc grpc.ClientConnInterface
}

func NewExceptionProfileSvcClient(cc grpc.ClientConnInterface) ExceptionProfileSvcClient {
	return &exceptionProfileSvcClient{cc}
}

func (c *exceptionProfileSvcClient) List(ctx context.Context, in *v1beta.ListOptions, opts ...grpc.CallOption) (*ExceptionProfileList, error) {
	out := new(ExceptionProfileList)
	err := c.cc.Invoke(ctx, ExceptionProfileSvc_List_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *exceptionProfileSvcClient) Create(ctx context.Context, in *ExceptionProfile, opts ...grpc.CallOption) (*ExceptionProfile, error) {
	out := new(ExceptionProfile)
	err := c.cc.Invoke(ctx, ExceptionProfileSvc_Create_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *exceptionProfileSvcClient) Get(ctx context.Context, in *v1beta.GetOptions, opts ...grpc.CallOption) (*ExceptionProfile, error) {
	out := new(ExceptionProfile)
	err := c.cc.Invoke(ctx, ExceptionProfileSvc_Get_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *exceptionProfileSvcClient) Update(ctx context.Context, in *ExceptionProfile, opts ...grpc.CallOption) (*ExceptionProfile, error) {
	out := new(ExceptionProfile)
	err := c.cc.Invoke(ctx, ExceptionProfileSvc_Update_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *exceptionProfileSvcClient) Delete(ctx context.Context, in *v1beta.DeleteOptions, opts ...grpc.CallOption) (*ExceptionProfile, error) {
	out := new(ExceptionProfile)
	err := c.cc.Invoke(ctx, ExceptionProfileSvc_Delete_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *exceptionProfileSvcClient) Watch(ctx context.Context, in *v1beta.WatchOptions, opts ...grpc.CallOption) (ExceptionProfileSvc_WatchClient, error) {
	stream, err := c.cc.NewStream(ctx, &ExceptionProfileSvc_ServiceDesc.Streams[0], ExceptionProfileSvc_Watch_FullMethodName, opts...)
	if err != nil {
		return nil, err
	}
	x := &exceptionProfileSvcWatchClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type ExceptionProfileSvc_WatchClient interface {
	Recv() (*v1beta.WatchEvent, error)
	grpc.ClientStream
}

type exceptionProfileSvcWatchClient struct {
	grpc.ClientStream
}

func (x *exceptionProfileSvcWatchClient) Recv() (*v1beta.WatchEvent, error) {
	m := new(v1beta.WatchEvent)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

// ExceptionProfileSvcServer is the server API for ExceptionProfileSvc service.
// All implementations must embed UnimplementedExceptionProfileSvcServer
// for forward compatibility
type ExceptionProfileSvcServer interface {
	List(context.Context, *v1beta.ListOptions) (*ExceptionProfileList, error)
	Create(context.Context, *ExceptionProfile) (*ExceptionProfile, error)
	Get(context.Context, *v1beta.GetOptions) (*ExceptionProfile, error)
	Update(context.Context, *ExceptionProfile) (*ExceptionProfile, error)
	Delete(context.Context, *v1beta.DeleteOptions) (*ExceptionProfile, error)
	Watch(*v1beta.WatchOptions, ExceptionProfileSvc_WatchServer) error
	mustEmbedUnimplementedExceptionProfileSvcServer()
}

// UnimplementedExceptionProfileSvcServer must be embedded to have forward compatible implementations.
type UnimplementedExceptionProfileSvcServer struct {
}

func (UnimplementedExceptionProfileSvcServer) List(context.Context, *v1beta.ListOptions) (*ExceptionProfileList, error) {
	return nil, status.Errorf(codes.Unimplemented, "method List not implemented")
}
func (UnimplementedExceptionProfileSvcServer) Create(context.Context, *ExceptionProfile) (*ExceptionProfile, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Create not implemented")
}
func (UnimplementedExceptionProfileSvcServer) Get(context.Context, *v1beta.GetOptions) (*ExceptionProfile, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Get not implemented")
}
func (UnimplementedExceptionProfileSvcServer) Update(context.Context, *ExceptionProfile) (*ExceptionProfile, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Update not implemented")
}
func (UnimplementedExceptionProfileSvcServer) Delete(context.Context, *v1beta.DeleteOptions) (*ExceptionProfile, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Delete not implemented")
}
func (UnimplementedExceptionProfileSvcServer) Watch(*v1beta.WatchOptions, ExceptionProfileSvc_WatchServer) error {
	return status.Errorf(codes.Unimplemented, "method Watch not implemented")
}
func (UnimplementedExceptionProfileSvcServer) mustEmbedUnimplementedExceptionProfileSvcServer() {}

// UnsafeExceptionProfileSvcServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to ExceptionProfileSvcServer will
// result in compilation errors.
type UnsafeExceptionProfileSvcServer interface {
	mustEmbedUnimplementedExceptionProfileSvcServer()
}

func RegisterExceptionProfileSvcServer(s grpc.ServiceRegistrar, srv ExceptionProfileSvcServer) {
	s.RegisterService(&ExceptionProfileSvc_ServiceDesc, srv)
}

func _ExceptionProfileSvc_List_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(v1beta.ListOptions)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ExceptionProfileSvcServer).List(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ExceptionProfileSvc_List_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ExceptionProfileSvcServer).List(ctx, req.(*v1beta.ListOptions))
	}
	return interceptor(ctx, in, info, handler)
}

func _ExceptionProfileSvc_Create_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ExceptionProfile)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ExceptionProfileSvcServer).Create(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ExceptionProfileSvc_Create_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ExceptionProfileSvcServer).Create(ctx, req.(*ExceptionProfile))
	}
	return interceptor(ctx, in, info, handler)
}

func _ExceptionProfileSvc_Get_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(v1beta.GetOptions)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ExceptionProfileSvcServer).Get(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ExceptionProfileSvc_Get_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ExceptionProfileSvcServer).Get(ctx, req.(*v1beta.GetOptions))
	}
	return interceptor(ctx, in, info, handler)
}

func _ExceptionProfileSvc_Update_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ExceptionProfile)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ExceptionProfileSvcServer).Update(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ExceptionProfileSvc_Update_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ExceptionProfileSvcServer).Update(ctx, req.(*ExceptionProfile))
	}
	return interceptor(ctx, in, info, handler)
}

func _ExceptionProfileSvc_Delete_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(v1beta.DeleteOptions)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ExceptionProfileSvcServer).Delete(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ExceptionProfileSvc_Delete_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ExceptionProfileSvcServer).Delete(ctx, req.(*v1beta.DeleteOptions))
	}
	return interceptor(ctx, in, info, handler)
}

func _ExceptionProfileSvc_Watch_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(v1beta.WatchOptions)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(ExceptionProfileSvcServer).Watch(m, &exceptionProfileSvcWatchServer{stream})
}

type ExceptionProfileSvc_WatchServer interface {
	Send(*v1beta.WatchEvent) error
	grpc.ServerStream
}

type exceptionProfileSvcWatchServer struct {
	grpc.ServerStream
}

func (x *exceptionProfileSvcWatchServer) Send(m *v1beta.WatchEvent) error {
	return x.ServerStream.SendMsg(m)
}

// ExceptionProfileSvc_ServiceDesc is the grpc.ServiceDesc for ExceptionProfileSvc service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var ExceptionProfileSvc_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "assets.ubika.io.v1beta.ExceptionProfileSvc",
	HandlerType: (*ExceptionProfileSvcServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "List",
			Handler:    _ExceptionProfileSvc_List_Handler,
		},
		{
			MethodName: "Create",
			Handler:    _ExceptionProfileSvc_Create_Handler,
		},
		{
			MethodName: "Get",
			Handler:    _ExceptionProfileSvc_Get_Handler,
		},
		{
			MethodName: "Update",
			Handler:    _ExceptionProfileSvc_Update_Handler,
		},
		{
			MethodName: "Delete",
			Handler:    _ExceptionProfileSvc_Delete_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "Watch",
			Handler:       _ExceptionProfileSvc_Watch_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "lib/proto/assets.ubika.io/v1beta/asset_service.proto",
}

const (
	ErrorDocumentSvc_List_FullMethodName   = "/assets.ubika.io.v1beta.ErrorDocumentSvc/List"
	ErrorDocumentSvc_Create_FullMethodName = "/assets.ubika.io.v1beta.ErrorDocumentSvc/Create"
	ErrorDocumentSvc_Get_FullMethodName    = "/assets.ubika.io.v1beta.ErrorDocumentSvc/Get"
	ErrorDocumentSvc_Update_FullMethodName = "/assets.ubika.io.v1beta.ErrorDocumentSvc/Update"
	ErrorDocumentSvc_Delete_FullMethodName = "/assets.ubika.io.v1beta.ErrorDocumentSvc/Delete"
	ErrorDocumentSvc_Watch_FullMethodName  = "/assets.ubika.io.v1beta.ErrorDocumentSvc/Watch"
)

// ErrorDocumentSvcClient is the client API for ErrorDocumentSvc service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type ErrorDocumentSvcClient interface {
	List(ctx context.Context, in *v1beta.ListOptions, opts ...grpc.CallOption) (*ErrorDocumentList, error)
	Create(ctx context.Context, in *ErrorDocument, opts ...grpc.CallOption) (*ErrorDocument, error)
	Get(ctx context.Context, in *v1beta.GetOptions, opts ...grpc.CallOption) (*ErrorDocument, error)
	Update(ctx context.Context, in *ErrorDocument, opts ...grpc.CallOption) (*ErrorDocument, error)
	Delete(ctx context.Context, in *v1beta.DeleteOptions, opts ...grpc.CallOption) (*ErrorDocument, error)
	Watch(ctx context.Context, in *v1beta.WatchOptions, opts ...grpc.CallOption) (ErrorDocumentSvc_WatchClient, error)
}

type errorDocumentSvcClient struct {
	cc grpc.ClientConnInterface
}

func NewErrorDocumentSvcClient(cc grpc.ClientConnInterface) ErrorDocumentSvcClient {
	return &errorDocumentSvcClient{cc}
}

func (c *errorDocumentSvcClient) List(ctx context.Context, in *v1beta.ListOptions, opts ...grpc.CallOption) (*ErrorDocumentList, error) {
	out := new(ErrorDocumentList)
	err := c.cc.Invoke(ctx, ErrorDocumentSvc_List_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *errorDocumentSvcClient) Create(ctx context.Context, in *ErrorDocument, opts ...grpc.CallOption) (*ErrorDocument, error) {
	out := new(ErrorDocument)
	err := c.cc.Invoke(ctx, ErrorDocumentSvc_Create_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *errorDocumentSvcClient) Get(ctx context.Context, in *v1beta.GetOptions, opts ...grpc.CallOption) (*ErrorDocument, error) {
	out := new(ErrorDocument)
	err := c.cc.Invoke(ctx, ErrorDocumentSvc_Get_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *errorDocumentSvcClient) Update(ctx context.Context, in *ErrorDocument, opts ...grpc.CallOption) (*ErrorDocument, error) {
	out := new(ErrorDocument)
	err := c.cc.Invoke(ctx, ErrorDocumentSvc_Update_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *errorDocumentSvcClient) Delete(ctx context.Context, in *v1beta.DeleteOptions, opts ...grpc.CallOption) (*ErrorDocument, error) {
	out := new(ErrorDocument)
	err := c.cc.Invoke(ctx, ErrorDocumentSvc_Delete_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *errorDocumentSvcClient) Watch(ctx context.Context, in *v1beta.WatchOptions, opts ...grpc.CallOption) (ErrorDocumentSvc_WatchClient, error) {
	stream, err := c.cc.NewStream(ctx, &ErrorDocumentSvc_ServiceDesc.Streams[0], ErrorDocumentSvc_Watch_FullMethodName, opts...)
	if err != nil {
		return nil, err
	}
	x := &errorDocumentSvcWatchClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type ErrorDocumentSvc_WatchClient interface {
	Recv() (*v1beta.WatchEvent, error)
	grpc.ClientStream
}

type errorDocumentSvcWatchClient struct {
	grpc.ClientStream
}

func (x *errorDocumentSvcWatchClient) Recv() (*v1beta.WatchEvent, error) {
	m := new(v1beta.WatchEvent)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

// ErrorDocumentSvcServer is the server API for ErrorDocumentSvc service.
// All implementations must embed UnimplementedErrorDocumentSvcServer
// for forward compatibility
type ErrorDocumentSvcServer interface {
	List(context.Context, *v1beta.ListOptions) (*ErrorDocumentList, error)
	Create(context.Context, *ErrorDocument) (*ErrorDocument, error)
	Get(context.Context, *v1beta.GetOptions) (*ErrorDocument, error)
	Update(context.Context, *ErrorDocument) (*ErrorDocument, error)
	Delete(context.Context, *v1beta.DeleteOptions) (*ErrorDocument, error)
	Watch(*v1beta.WatchOptions, ErrorDocumentSvc_WatchServer) error
	mustEmbedUnimplementedErrorDocumentSvcServer()
}

// UnimplementedErrorDocumentSvcServer must be embedded to have forward compatible implementations.
type UnimplementedErrorDocumentSvcServer struct {
}

func (UnimplementedErrorDocumentSvcServer) List(context.Context, *v1beta.ListOptions) (*ErrorDocumentList, error) {
	return nil, status.Errorf(codes.Unimplemented, "method List not implemented")
}
func (UnimplementedErrorDocumentSvcServer) Create(context.Context, *ErrorDocument) (*ErrorDocument, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Create not implemented")
}
func (UnimplementedErrorDocumentSvcServer) Get(context.Context, *v1beta.GetOptions) (*ErrorDocument, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Get not implemented")
}
func (UnimplementedErrorDocumentSvcServer) Update(context.Context, *ErrorDocument) (*ErrorDocument, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Update not implemented")
}
func (UnimplementedErrorDocumentSvcServer) Delete(context.Context, *v1beta.DeleteOptions) (*ErrorDocument, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Delete not implemented")
}
func (UnimplementedErrorDocumentSvcServer) Watch(*v1beta.WatchOptions, ErrorDocumentSvc_WatchServer) error {
	return status.Errorf(codes.Unimplemented, "method Watch not implemented")
}
func (UnimplementedErrorDocumentSvcServer) mustEmbedUnimplementedErrorDocumentSvcServer() {}

// UnsafeErrorDocumentSvcServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to ErrorDocumentSvcServer will
// result in compilation errors.
type UnsafeErrorDocumentSvcServer interface {
	mustEmbedUnimplementedErrorDocumentSvcServer()
}

func RegisterErrorDocumentSvcServer(s grpc.ServiceRegistrar, srv ErrorDocumentSvcServer) {
	s.RegisterService(&ErrorDocumentSvc_ServiceDesc, srv)
}

func _ErrorDocumentSvc_List_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(v1beta.ListOptions)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ErrorDocumentSvcServer).List(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ErrorDocumentSvc_List_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ErrorDocumentSvcServer).List(ctx, req.(*v1beta.ListOptions))
	}
	return interceptor(ctx, in, info, handler)
}

func _ErrorDocumentSvc_Create_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ErrorDocument)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ErrorDocumentSvcServer).Create(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ErrorDocumentSvc_Create_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ErrorDocumentSvcServer).Create(ctx, req.(*ErrorDocument))
	}
	return interceptor(ctx, in, info, handler)
}

func _ErrorDocumentSvc_Get_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(v1beta.GetOptions)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ErrorDocumentSvcServer).Get(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ErrorDocumentSvc_Get_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ErrorDocumentSvcServer).Get(ctx, req.(*v1beta.GetOptions))
	}
	return interceptor(ctx, in, info, handler)
}

func _ErrorDocumentSvc_Update_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ErrorDocument)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ErrorDocumentSvcServer).Update(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ErrorDocumentSvc_Update_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ErrorDocumentSvcServer).Update(ctx, req.(*ErrorDocument))
	}
	return interceptor(ctx, in, info, handler)
}

func _ErrorDocumentSvc_Delete_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(v1beta.DeleteOptions)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ErrorDocumentSvcServer).Delete(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ErrorDocumentSvc_Delete_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ErrorDocumentSvcServer).Delete(ctx, req.(*v1beta.DeleteOptions))
	}
	return interceptor(ctx, in, info, handler)
}

func _ErrorDocumentSvc_Watch_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(v1beta.WatchOptions)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(ErrorDocumentSvcServer).Watch(m, &errorDocumentSvcWatchServer{stream})
}

type ErrorDocumentSvc_WatchServer interface {
	Send(*v1beta.WatchEvent) error
	grpc.ServerStream
}

type errorDocumentSvcWatchServer struct {
	grpc.ServerStream
}

func (x *errorDocumentSvcWatchServer) Send(m *v1beta.WatchEvent) error {
	return x.ServerStream.SendMsg(m)
}

// ErrorDocumentSvc_ServiceDesc is the grpc.ServiceDesc for ErrorDocumentSvc service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var ErrorDocumentSvc_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "assets.ubika.io.v1beta.ErrorDocumentSvc",
	HandlerType: (*ErrorDocumentSvcServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "List",
			Handler:    _ErrorDocumentSvc_List_Handler,
		},
		{
			MethodName: "Create",
			Handler:    _ErrorDocumentSvc_Create_Handler,
		},
		{
			MethodName: "Get",
			Handler:    _ErrorDocumentSvc_Get_Handler,
		},
		{
			MethodName: "Update",
			Handler:    _ErrorDocumentSvc_Update_Handler,
		},
		{
			MethodName: "Delete",
			Handler:    _ErrorDocumentSvc_Delete_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "Watch",
			Handler:       _ErrorDocumentSvc_Watch_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "lib/proto/assets.ubika.io/v1beta/asset_service.proto",
}

const (
	TLSConfigurationSvc_List_FullMethodName                 = "/assets.ubika.io.v1beta.TLSConfigurationSvc/List"
	TLSConfigurationSvc_Create_FullMethodName               = "/assets.ubika.io.v1beta.TLSConfigurationSvc/Create"
	TLSConfigurationSvc_Get_FullMethodName                  = "/assets.ubika.io.v1beta.TLSConfigurationSvc/Get"
	TLSConfigurationSvc_Update_FullMethodName               = "/assets.ubika.io.v1beta.TLSConfigurationSvc/Update"
	TLSConfigurationSvc_Delete_FullMethodName               = "/assets.ubika.io.v1beta.TLSConfigurationSvc/Delete"
	TLSConfigurationSvc_Watch_FullMethodName                = "/assets.ubika.io.v1beta.TLSConfigurationSvc/Watch"
	TLSConfigurationSvc_ListCSR_FullMethodName              = "/assets.ubika.io.v1beta.TLSConfigurationSvc/ListCSR"
	TLSConfigurationSvc_CreateCSR_FullMethodName            = "/assets.ubika.io.v1beta.TLSConfigurationSvc/CreateCSR"
	TLSConfigurationSvc_GetCSR_FullMethodName               = "/assets.ubika.io.v1beta.TLSConfigurationSvc/GetCSR"
	TLSConfigurationSvc_DeleteCSR_FullMethodName            = "/assets.ubika.io.v1beta.TLSConfigurationSvc/DeleteCSR"
	TLSConfigurationSvc_UpdateCSRCertificate_FullMethodName = "/assets.ubika.io.v1beta.TLSConfigurationSvc/UpdateCSRCertificate"
	TLSConfigurationSvc_CreateManualTLS_FullMethodName      = "/assets.ubika.io.v1beta.TLSConfigurationSvc/CreateManualTLS"
	TLSConfigurationSvc_UpdateManualTLS_FullMethodName      = "/assets.ubika.io.v1beta.TLSConfigurationSvc/UpdateManualTLS"
	TLSConfigurationSvc_DeleteTLSMaterial_FullMethodName    = "/assets.ubika.io.v1beta.TLSConfigurationSvc/DeleteTLSMaterial"
	TLSConfigurationSvc_GetTLSMaterial_FullMethodName       = "/assets.ubika.io.v1beta.TLSConfigurationSvc/GetTLSMaterial"
	TLSConfigurationSvc_ListTLSMaterial_FullMethodName      = "/assets.ubika.io.v1beta.TLSConfigurationSvc/ListTLSMaterial"
	TLSConfigurationSvc_Default_FullMethodName              = "/assets.ubika.io.v1beta.TLSConfigurationSvc/Default"
	TLSConfigurationSvc_DefaultSelfHosted_FullMethodName    = "/assets.ubika.io.v1beta.TLSConfigurationSvc/DefaultSelfHosted"
)

// TLSConfigurationSvcClient is the client API for TLSConfigurationSvc service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type TLSConfigurationSvcClient interface {
	List(ctx context.Context, in *v1beta.ListOptions, opts ...grpc.CallOption) (*TLSConfigurationList, error)
	Create(ctx context.Context, in *TLSConfiguration, opts ...grpc.CallOption) (*TLSConfiguration, error)
	Get(ctx context.Context, in *v1beta.GetOptions, opts ...grpc.CallOption) (*TLSConfiguration, error)
	Update(ctx context.Context, in *TLSConfiguration, opts ...grpc.CallOption) (*TLSConfiguration, error)
	Delete(ctx context.Context, in *v1beta.DeleteOptions, opts ...grpc.CallOption) (*TLSConfiguration, error)
	Watch(ctx context.Context, in *v1beta.WatchOptions, opts ...grpc.CallOption) (TLSConfigurationSvc_WatchClient, error)
	ListCSR(ctx context.Context, in *v1beta.ListOptions, opts ...grpc.CallOption) (*CSRList, error)
	CreateCSR(ctx context.Context, in *CSRCreate, opts ...grpc.CallOption) (*CSR, error)
	GetCSR(ctx context.Context, in *v1beta.GetOptions, opts ...grpc.CallOption) (*CSR, error)
	DeleteCSR(ctx context.Context, in *v1beta.DeleteOptions, opts ...grpc.CallOption) (*CSR, error)
	UpdateCSRCertificate(ctx context.Context, in *CSRCertificate, opts ...grpc.CallOption) (*TLSMaterial, error)
	CreateManualTLS(ctx context.Context, in *TLSManualCreate, opts ...grpc.CallOption) (*TLSMaterial, error)
	UpdateManualTLS(ctx context.Context, in *TLSManualCreate, opts ...grpc.CallOption) (*TLSMaterial, error)
	DeleteTLSMaterial(ctx context.Context, in *v1beta.DeleteOptions, opts ...grpc.CallOption) (*TLSMaterial, error)
	GetTLSMaterial(ctx context.Context, in *v1beta.GetOptions, opts ...grpc.CallOption) (*TLSMaterial, error)
	ListTLSMaterial(ctx context.Context, in *v1beta.ListOptions, opts ...grpc.CallOption) (*TLSMaterialList, error)
	// Defaults returns the list of available TLS configuration and defaults
	Default(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*TLSConfigurationDefault, error)
	DefaultSelfHosted(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*TLSConfigurationDefault, error)
}

type tLSConfigurationSvcClient struct {
	cc grpc.ClientConnInterface
}

func NewTLSConfigurationSvcClient(cc grpc.ClientConnInterface) TLSConfigurationSvcClient {
	return &tLSConfigurationSvcClient{cc}
}

func (c *tLSConfigurationSvcClient) List(ctx context.Context, in *v1beta.ListOptions, opts ...grpc.CallOption) (*TLSConfigurationList, error) {
	out := new(TLSConfigurationList)
	err := c.cc.Invoke(ctx, TLSConfigurationSvc_List_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *tLSConfigurationSvcClient) Create(ctx context.Context, in *TLSConfiguration, opts ...grpc.CallOption) (*TLSConfiguration, error) {
	out := new(TLSConfiguration)
	err := c.cc.Invoke(ctx, TLSConfigurationSvc_Create_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *tLSConfigurationSvcClient) Get(ctx context.Context, in *v1beta.GetOptions, opts ...grpc.CallOption) (*TLSConfiguration, error) {
	out := new(TLSConfiguration)
	err := c.cc.Invoke(ctx, TLSConfigurationSvc_Get_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *tLSConfigurationSvcClient) Update(ctx context.Context, in *TLSConfiguration, opts ...grpc.CallOption) (*TLSConfiguration, error) {
	out := new(TLSConfiguration)
	err := c.cc.Invoke(ctx, TLSConfigurationSvc_Update_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *tLSConfigurationSvcClient) Delete(ctx context.Context, in *v1beta.DeleteOptions, opts ...grpc.CallOption) (*TLSConfiguration, error) {
	out := new(TLSConfiguration)
	err := c.cc.Invoke(ctx, TLSConfigurationSvc_Delete_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *tLSConfigurationSvcClient) Watch(ctx context.Context, in *v1beta.WatchOptions, opts ...grpc.CallOption) (TLSConfigurationSvc_WatchClient, error) {
	stream, err := c.cc.NewStream(ctx, &TLSConfigurationSvc_ServiceDesc.Streams[0], TLSConfigurationSvc_Watch_FullMethodName, opts...)
	if err != nil {
		return nil, err
	}
	x := &tLSConfigurationSvcWatchClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type TLSConfigurationSvc_WatchClient interface {
	Recv() (*v1beta.WatchEvent, error)
	grpc.ClientStream
}

type tLSConfigurationSvcWatchClient struct {
	grpc.ClientStream
}

func (x *tLSConfigurationSvcWatchClient) Recv() (*v1beta.WatchEvent, error) {
	m := new(v1beta.WatchEvent)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *tLSConfigurationSvcClient) ListCSR(ctx context.Context, in *v1beta.ListOptions, opts ...grpc.CallOption) (*CSRList, error) {
	out := new(CSRList)
	err := c.cc.Invoke(ctx, TLSConfigurationSvc_ListCSR_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *tLSConfigurationSvcClient) CreateCSR(ctx context.Context, in *CSRCreate, opts ...grpc.CallOption) (*CSR, error) {
	out := new(CSR)
	err := c.cc.Invoke(ctx, TLSConfigurationSvc_CreateCSR_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *tLSConfigurationSvcClient) GetCSR(ctx context.Context, in *v1beta.GetOptions, opts ...grpc.CallOption) (*CSR, error) {
	out := new(CSR)
	err := c.cc.Invoke(ctx, TLSConfigurationSvc_GetCSR_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *tLSConfigurationSvcClient) DeleteCSR(ctx context.Context, in *v1beta.DeleteOptions, opts ...grpc.CallOption) (*CSR, error) {
	out := new(CSR)
	err := c.cc.Invoke(ctx, TLSConfigurationSvc_DeleteCSR_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *tLSConfigurationSvcClient) UpdateCSRCertificate(ctx context.Context, in *CSRCertificate, opts ...grpc.CallOption) (*TLSMaterial, error) {
	out := new(TLSMaterial)
	err := c.cc.Invoke(ctx, TLSConfigurationSvc_UpdateCSRCertificate_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *tLSConfigurationSvcClient) CreateManualTLS(ctx context.Context, in *TLSManualCreate, opts ...grpc.CallOption) (*TLSMaterial, error) {
	out := new(TLSMaterial)
	err := c.cc.Invoke(ctx, TLSConfigurationSvc_CreateManualTLS_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *tLSConfigurationSvcClient) UpdateManualTLS(ctx context.Context, in *TLSManualCreate, opts ...grpc.CallOption) (*TLSMaterial, error) {
	out := new(TLSMaterial)
	err := c.cc.Invoke(ctx, TLSConfigurationSvc_UpdateManualTLS_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *tLSConfigurationSvcClient) DeleteTLSMaterial(ctx context.Context, in *v1beta.DeleteOptions, opts ...grpc.CallOption) (*TLSMaterial, error) {
	out := new(TLSMaterial)
	err := c.cc.Invoke(ctx, TLSConfigurationSvc_DeleteTLSMaterial_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *tLSConfigurationSvcClient) GetTLSMaterial(ctx context.Context, in *v1beta.GetOptions, opts ...grpc.CallOption) (*TLSMaterial, error) {
	out := new(TLSMaterial)
	err := c.cc.Invoke(ctx, TLSConfigurationSvc_GetTLSMaterial_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *tLSConfigurationSvcClient) ListTLSMaterial(ctx context.Context, in *v1beta.ListOptions, opts ...grpc.CallOption) (*TLSMaterialList, error) {
	out := new(TLSMaterialList)
	err := c.cc.Invoke(ctx, TLSConfigurationSvc_ListTLSMaterial_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *tLSConfigurationSvcClient) Default(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*TLSConfigurationDefault, error) {
	out := new(TLSConfigurationDefault)
	err := c.cc.Invoke(ctx, TLSConfigurationSvc_Default_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *tLSConfigurationSvcClient) DefaultSelfHosted(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*TLSConfigurationDefault, error) {
	out := new(TLSConfigurationDefault)
	err := c.cc.Invoke(ctx, TLSConfigurationSvc_DefaultSelfHosted_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// TLSConfigurationSvcServer is the server API for TLSConfigurationSvc service.
// All implementations must embed UnimplementedTLSConfigurationSvcServer
// for forward compatibility
type TLSConfigurationSvcServer interface {
	List(context.Context, *v1beta.ListOptions) (*TLSConfigurationList, error)
	Create(context.Context, *TLSConfiguration) (*TLSConfiguration, error)
	Get(context.Context, *v1beta.GetOptions) (*TLSConfiguration, error)
	Update(context.Context, *TLSConfiguration) (*TLSConfiguration, error)
	Delete(context.Context, *v1beta.DeleteOptions) (*TLSConfiguration, error)
	Watch(*v1beta.WatchOptions, TLSConfigurationSvc_WatchServer) error
	ListCSR(context.Context, *v1beta.ListOptions) (*CSRList, error)
	CreateCSR(context.Context, *CSRCreate) (*CSR, error)
	GetCSR(context.Context, *v1beta.GetOptions) (*CSR, error)
	DeleteCSR(context.Context, *v1beta.DeleteOptions) (*CSR, error)
	UpdateCSRCertificate(context.Context, *CSRCertificate) (*TLSMaterial, error)
	CreateManualTLS(context.Context, *TLSManualCreate) (*TLSMaterial, error)
	UpdateManualTLS(context.Context, *TLSManualCreate) (*TLSMaterial, error)
	DeleteTLSMaterial(context.Context, *v1beta.DeleteOptions) (*TLSMaterial, error)
	GetTLSMaterial(context.Context, *v1beta.GetOptions) (*TLSMaterial, error)
	ListTLSMaterial(context.Context, *v1beta.ListOptions) (*TLSMaterialList, error)
	// Defaults returns the list of available TLS configuration and defaults
	Default(context.Context, *emptypb.Empty) (*TLSConfigurationDefault, error)
	DefaultSelfHosted(context.Context, *emptypb.Empty) (*TLSConfigurationDefault, error)
	mustEmbedUnimplementedTLSConfigurationSvcServer()
}

// UnimplementedTLSConfigurationSvcServer must be embedded to have forward compatible implementations.
type UnimplementedTLSConfigurationSvcServer struct {
}

func (UnimplementedTLSConfigurationSvcServer) List(context.Context, *v1beta.ListOptions) (*TLSConfigurationList, error) {
	return nil, status.Errorf(codes.Unimplemented, "method List not implemented")
}
func (UnimplementedTLSConfigurationSvcServer) Create(context.Context, *TLSConfiguration) (*TLSConfiguration, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Create not implemented")
}
func (UnimplementedTLSConfigurationSvcServer) Get(context.Context, *v1beta.GetOptions) (*TLSConfiguration, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Get not implemented")
}
func (UnimplementedTLSConfigurationSvcServer) Update(context.Context, *TLSConfiguration) (*TLSConfiguration, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Update not implemented")
}
func (UnimplementedTLSConfigurationSvcServer) Delete(context.Context, *v1beta.DeleteOptions) (*TLSConfiguration, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Delete not implemented")
}
func (UnimplementedTLSConfigurationSvcServer) Watch(*v1beta.WatchOptions, TLSConfigurationSvc_WatchServer) error {
	return status.Errorf(codes.Unimplemented, "method Watch not implemented")
}
func (UnimplementedTLSConfigurationSvcServer) ListCSR(context.Context, *v1beta.ListOptions) (*CSRList, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListCSR not implemented")
}
func (UnimplementedTLSConfigurationSvcServer) CreateCSR(context.Context, *CSRCreate) (*CSR, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateCSR not implemented")
}
func (UnimplementedTLSConfigurationSvcServer) GetCSR(context.Context, *v1beta.GetOptions) (*CSR, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetCSR not implemented")
}
func (UnimplementedTLSConfigurationSvcServer) DeleteCSR(context.Context, *v1beta.DeleteOptions) (*CSR, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteCSR not implemented")
}
func (UnimplementedTLSConfigurationSvcServer) UpdateCSRCertificate(context.Context, *CSRCertificate) (*TLSMaterial, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateCSRCertificate not implemented")
}
func (UnimplementedTLSConfigurationSvcServer) CreateManualTLS(context.Context, *TLSManualCreate) (*TLSMaterial, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateManualTLS not implemented")
}
func (UnimplementedTLSConfigurationSvcServer) UpdateManualTLS(context.Context, *TLSManualCreate) (*TLSMaterial, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateManualTLS not implemented")
}
func (UnimplementedTLSConfigurationSvcServer) DeleteTLSMaterial(context.Context, *v1beta.DeleteOptions) (*TLSMaterial, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteTLSMaterial not implemented")
}
func (UnimplementedTLSConfigurationSvcServer) GetTLSMaterial(context.Context, *v1beta.GetOptions) (*TLSMaterial, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetTLSMaterial not implemented")
}
func (UnimplementedTLSConfigurationSvcServer) ListTLSMaterial(context.Context, *v1beta.ListOptions) (*TLSMaterialList, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListTLSMaterial not implemented")
}
func (UnimplementedTLSConfigurationSvcServer) Default(context.Context, *emptypb.Empty) (*TLSConfigurationDefault, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Default not implemented")
}
func (UnimplementedTLSConfigurationSvcServer) DefaultSelfHosted(context.Context, *emptypb.Empty) (*TLSConfigurationDefault, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DefaultSelfHosted not implemented")
}
func (UnimplementedTLSConfigurationSvcServer) mustEmbedUnimplementedTLSConfigurationSvcServer() {}

// UnsafeTLSConfigurationSvcServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to TLSConfigurationSvcServer will
// result in compilation errors.
type UnsafeTLSConfigurationSvcServer interface {
	mustEmbedUnimplementedTLSConfigurationSvcServer()
}

func RegisterTLSConfigurationSvcServer(s grpc.ServiceRegistrar, srv TLSConfigurationSvcServer) {
	s.RegisterService(&TLSConfigurationSvc_ServiceDesc, srv)
}

func _TLSConfigurationSvc_List_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(v1beta.ListOptions)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TLSConfigurationSvcServer).List(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: TLSConfigurationSvc_List_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TLSConfigurationSvcServer).List(ctx, req.(*v1beta.ListOptions))
	}
	return interceptor(ctx, in, info, handler)
}

func _TLSConfigurationSvc_Create_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TLSConfiguration)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TLSConfigurationSvcServer).Create(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: TLSConfigurationSvc_Create_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TLSConfigurationSvcServer).Create(ctx, req.(*TLSConfiguration))
	}
	return interceptor(ctx, in, info, handler)
}

func _TLSConfigurationSvc_Get_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(v1beta.GetOptions)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TLSConfigurationSvcServer).Get(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: TLSConfigurationSvc_Get_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TLSConfigurationSvcServer).Get(ctx, req.(*v1beta.GetOptions))
	}
	return interceptor(ctx, in, info, handler)
}

func _TLSConfigurationSvc_Update_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TLSConfiguration)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TLSConfigurationSvcServer).Update(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: TLSConfigurationSvc_Update_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TLSConfigurationSvcServer).Update(ctx, req.(*TLSConfiguration))
	}
	return interceptor(ctx, in, info, handler)
}

func _TLSConfigurationSvc_Delete_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(v1beta.DeleteOptions)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TLSConfigurationSvcServer).Delete(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: TLSConfigurationSvc_Delete_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TLSConfigurationSvcServer).Delete(ctx, req.(*v1beta.DeleteOptions))
	}
	return interceptor(ctx, in, info, handler)
}

func _TLSConfigurationSvc_Watch_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(v1beta.WatchOptions)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(TLSConfigurationSvcServer).Watch(m, &tLSConfigurationSvcWatchServer{stream})
}

type TLSConfigurationSvc_WatchServer interface {
	Send(*v1beta.WatchEvent) error
	grpc.ServerStream
}

type tLSConfigurationSvcWatchServer struct {
	grpc.ServerStream
}

func (x *tLSConfigurationSvcWatchServer) Send(m *v1beta.WatchEvent) error {
	return x.ServerStream.SendMsg(m)
}

func _TLSConfigurationSvc_ListCSR_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(v1beta.ListOptions)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TLSConfigurationSvcServer).ListCSR(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: TLSConfigurationSvc_ListCSR_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TLSConfigurationSvcServer).ListCSR(ctx, req.(*v1beta.ListOptions))
	}
	return interceptor(ctx, in, info, handler)
}

func _TLSConfigurationSvc_CreateCSR_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CSRCreate)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TLSConfigurationSvcServer).CreateCSR(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: TLSConfigurationSvc_CreateCSR_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TLSConfigurationSvcServer).CreateCSR(ctx, req.(*CSRCreate))
	}
	return interceptor(ctx, in, info, handler)
}

func _TLSConfigurationSvc_GetCSR_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(v1beta.GetOptions)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TLSConfigurationSvcServer).GetCSR(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: TLSConfigurationSvc_GetCSR_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TLSConfigurationSvcServer).GetCSR(ctx, req.(*v1beta.GetOptions))
	}
	return interceptor(ctx, in, info, handler)
}

func _TLSConfigurationSvc_DeleteCSR_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(v1beta.DeleteOptions)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TLSConfigurationSvcServer).DeleteCSR(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: TLSConfigurationSvc_DeleteCSR_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TLSConfigurationSvcServer).DeleteCSR(ctx, req.(*v1beta.DeleteOptions))
	}
	return interceptor(ctx, in, info, handler)
}

func _TLSConfigurationSvc_UpdateCSRCertificate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CSRCertificate)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TLSConfigurationSvcServer).UpdateCSRCertificate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: TLSConfigurationSvc_UpdateCSRCertificate_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TLSConfigurationSvcServer).UpdateCSRCertificate(ctx, req.(*CSRCertificate))
	}
	return interceptor(ctx, in, info, handler)
}

func _TLSConfigurationSvc_CreateManualTLS_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TLSManualCreate)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TLSConfigurationSvcServer).CreateManualTLS(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: TLSConfigurationSvc_CreateManualTLS_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TLSConfigurationSvcServer).CreateManualTLS(ctx, req.(*TLSManualCreate))
	}
	return interceptor(ctx, in, info, handler)
}

func _TLSConfigurationSvc_UpdateManualTLS_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TLSManualCreate)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TLSConfigurationSvcServer).UpdateManualTLS(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: TLSConfigurationSvc_UpdateManualTLS_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TLSConfigurationSvcServer).UpdateManualTLS(ctx, req.(*TLSManualCreate))
	}
	return interceptor(ctx, in, info, handler)
}

func _TLSConfigurationSvc_DeleteTLSMaterial_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(v1beta.DeleteOptions)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TLSConfigurationSvcServer).DeleteTLSMaterial(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: TLSConfigurationSvc_DeleteTLSMaterial_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TLSConfigurationSvcServer).DeleteTLSMaterial(ctx, req.(*v1beta.DeleteOptions))
	}
	return interceptor(ctx, in, info, handler)
}

func _TLSConfigurationSvc_GetTLSMaterial_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(v1beta.GetOptions)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TLSConfigurationSvcServer).GetTLSMaterial(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: TLSConfigurationSvc_GetTLSMaterial_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TLSConfigurationSvcServer).GetTLSMaterial(ctx, req.(*v1beta.GetOptions))
	}
	return interceptor(ctx, in, info, handler)
}

func _TLSConfigurationSvc_ListTLSMaterial_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(v1beta.ListOptions)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TLSConfigurationSvcServer).ListTLSMaterial(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: TLSConfigurationSvc_ListTLSMaterial_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TLSConfigurationSvcServer).ListTLSMaterial(ctx, req.(*v1beta.ListOptions))
	}
	return interceptor(ctx, in, info, handler)
}

func _TLSConfigurationSvc_Default_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(emptypb.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TLSConfigurationSvcServer).Default(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: TLSConfigurationSvc_Default_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TLSConfigurationSvcServer).Default(ctx, req.(*emptypb.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _TLSConfigurationSvc_DefaultSelfHosted_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(emptypb.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TLSConfigurationSvcServer).DefaultSelfHosted(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: TLSConfigurationSvc_DefaultSelfHosted_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TLSConfigurationSvcServer).DefaultSelfHosted(ctx, req.(*emptypb.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

// TLSConfigurationSvc_ServiceDesc is the grpc.ServiceDesc for TLSConfigurationSvc service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var TLSConfigurationSvc_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "assets.ubika.io.v1beta.TLSConfigurationSvc",
	HandlerType: (*TLSConfigurationSvcServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "List",
			Handler:    _TLSConfigurationSvc_List_Handler,
		},
		{
			MethodName: "Create",
			Handler:    _TLSConfigurationSvc_Create_Handler,
		},
		{
			MethodName: "Get",
			Handler:    _TLSConfigurationSvc_Get_Handler,
		},
		{
			MethodName: "Update",
			Handler:    _TLSConfigurationSvc_Update_Handler,
		},
		{
			MethodName: "Delete",
			Handler:    _TLSConfigurationSvc_Delete_Handler,
		},
		{
			MethodName: "ListCSR",
			Handler:    _TLSConfigurationSvc_ListCSR_Handler,
		},
		{
			MethodName: "CreateCSR",
			Handler:    _TLSConfigurationSvc_CreateCSR_Handler,
		},
		{
			MethodName: "GetCSR",
			Handler:    _TLSConfigurationSvc_GetCSR_Handler,
		},
		{
			MethodName: "DeleteCSR",
			Handler:    _TLSConfigurationSvc_DeleteCSR_Handler,
		},
		{
			MethodName: "UpdateCSRCertificate",
			Handler:    _TLSConfigurationSvc_UpdateCSRCertificate_Handler,
		},
		{
			MethodName: "CreateManualTLS",
			Handler:    _TLSConfigurationSvc_CreateManualTLS_Handler,
		},
		{
			MethodName: "UpdateManualTLS",
			Handler:    _TLSConfigurationSvc_UpdateManualTLS_Handler,
		},
		{
			MethodName: "DeleteTLSMaterial",
			Handler:    _TLSConfigurationSvc_DeleteTLSMaterial_Handler,
		},
		{
			MethodName: "GetTLSMaterial",
			Handler:    _TLSConfigurationSvc_GetTLSMaterial_Handler,
		},
		{
			MethodName: "ListTLSMaterial",
			Handler:    _TLSConfigurationSvc_ListTLSMaterial_Handler,
		},
		{
			MethodName: "Default",
			Handler:    _TLSConfigurationSvc_Default_Handler,
		},
		{
			MethodName: "DefaultSelfHosted",
			Handler:    _TLSConfigurationSvc_DefaultSelfHosted_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "Watch",
			Handler:       _TLSConfigurationSvc_Watch_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "lib/proto/assets.ubika.io/v1beta/asset_service.proto",
}

const (
	TLSMaterialInternalSvc_Get_FullMethodName   = "/assets.ubika.io.v1beta.TLSMaterialInternalSvc/Get"
	TLSMaterialInternalSvc_List_FullMethodName  = "/assets.ubika.io.v1beta.TLSMaterialInternalSvc/List"
	TLSMaterialInternalSvc_Watch_FullMethodName = "/assets.ubika.io.v1beta.TLSMaterialInternalSvc/Watch"
)

// TLSMaterialInternalSvcClient is the client API for TLSMaterialInternalSvc service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type TLSMaterialInternalSvcClient interface {
	Get(ctx context.Context, in *v1beta.GetOptions, opts ...grpc.CallOption) (*TLSMaterialFull, error)
	List(ctx context.Context, in *v1beta.ListOptions, opts ...grpc.CallOption) (*TLSMaterialFullList, error)
	Watch(ctx context.Context, in *v1beta.WatchOptions, opts ...grpc.CallOption) (TLSMaterialInternalSvc_WatchClient, error)
}

type tLSMaterialInternalSvcClient struct {
	cc grpc.ClientConnInterface
}

func NewTLSMaterialInternalSvcClient(cc grpc.ClientConnInterface) TLSMaterialInternalSvcClient {
	return &tLSMaterialInternalSvcClient{cc}
}

func (c *tLSMaterialInternalSvcClient) Get(ctx context.Context, in *v1beta.GetOptions, opts ...grpc.CallOption) (*TLSMaterialFull, error) {
	out := new(TLSMaterialFull)
	err := c.cc.Invoke(ctx, TLSMaterialInternalSvc_Get_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *tLSMaterialInternalSvcClient) List(ctx context.Context, in *v1beta.ListOptions, opts ...grpc.CallOption) (*TLSMaterialFullList, error) {
	out := new(TLSMaterialFullList)
	err := c.cc.Invoke(ctx, TLSMaterialInternalSvc_List_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *tLSMaterialInternalSvcClient) Watch(ctx context.Context, in *v1beta.WatchOptions, opts ...grpc.CallOption) (TLSMaterialInternalSvc_WatchClient, error) {
	stream, err := c.cc.NewStream(ctx, &TLSMaterialInternalSvc_ServiceDesc.Streams[0], TLSMaterialInternalSvc_Watch_FullMethodName, opts...)
	if err != nil {
		return nil, err
	}
	x := &tLSMaterialInternalSvcWatchClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type TLSMaterialInternalSvc_WatchClient interface {
	Recv() (*v1beta.WatchEvent, error)
	grpc.ClientStream
}

type tLSMaterialInternalSvcWatchClient struct {
	grpc.ClientStream
}

func (x *tLSMaterialInternalSvcWatchClient) Recv() (*v1beta.WatchEvent, error) {
	m := new(v1beta.WatchEvent)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

// TLSMaterialInternalSvcServer is the server API for TLSMaterialInternalSvc service.
// All implementations must embed UnimplementedTLSMaterialInternalSvcServer
// for forward compatibility
type TLSMaterialInternalSvcServer interface {
	Get(context.Context, *v1beta.GetOptions) (*TLSMaterialFull, error)
	List(context.Context, *v1beta.ListOptions) (*TLSMaterialFullList, error)
	Watch(*v1beta.WatchOptions, TLSMaterialInternalSvc_WatchServer) error
	mustEmbedUnimplementedTLSMaterialInternalSvcServer()
}

// UnimplementedTLSMaterialInternalSvcServer must be embedded to have forward compatible implementations.
type UnimplementedTLSMaterialInternalSvcServer struct {
}

func (UnimplementedTLSMaterialInternalSvcServer) Get(context.Context, *v1beta.GetOptions) (*TLSMaterialFull, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Get not implemented")
}
func (UnimplementedTLSMaterialInternalSvcServer) List(context.Context, *v1beta.ListOptions) (*TLSMaterialFullList, error) {
	return nil, status.Errorf(codes.Unimplemented, "method List not implemented")
}
func (UnimplementedTLSMaterialInternalSvcServer) Watch(*v1beta.WatchOptions, TLSMaterialInternalSvc_WatchServer) error {
	return status.Errorf(codes.Unimplemented, "method Watch not implemented")
}
func (UnimplementedTLSMaterialInternalSvcServer) mustEmbedUnimplementedTLSMaterialInternalSvcServer() {
}

// UnsafeTLSMaterialInternalSvcServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to TLSMaterialInternalSvcServer will
// result in compilation errors.
type UnsafeTLSMaterialInternalSvcServer interface {
	mustEmbedUnimplementedTLSMaterialInternalSvcServer()
}

func RegisterTLSMaterialInternalSvcServer(s grpc.ServiceRegistrar, srv TLSMaterialInternalSvcServer) {
	s.RegisterService(&TLSMaterialInternalSvc_ServiceDesc, srv)
}

func _TLSMaterialInternalSvc_Get_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(v1beta.GetOptions)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TLSMaterialInternalSvcServer).Get(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: TLSMaterialInternalSvc_Get_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TLSMaterialInternalSvcServer).Get(ctx, req.(*v1beta.GetOptions))
	}
	return interceptor(ctx, in, info, handler)
}

func _TLSMaterialInternalSvc_List_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(v1beta.ListOptions)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TLSMaterialInternalSvcServer).List(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: TLSMaterialInternalSvc_List_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TLSMaterialInternalSvcServer).List(ctx, req.(*v1beta.ListOptions))
	}
	return interceptor(ctx, in, info, handler)
}

func _TLSMaterialInternalSvc_Watch_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(v1beta.WatchOptions)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(TLSMaterialInternalSvcServer).Watch(m, &tLSMaterialInternalSvcWatchServer{stream})
}

type TLSMaterialInternalSvc_WatchServer interface {
	Send(*v1beta.WatchEvent) error
	grpc.ServerStream
}

type tLSMaterialInternalSvcWatchServer struct {
	grpc.ServerStream
}

func (x *tLSMaterialInternalSvcWatchServer) Send(m *v1beta.WatchEvent) error {
	return x.ServerStream.SendMsg(m)
}

// TLSMaterialInternalSvc_ServiceDesc is the grpc.ServiceDesc for TLSMaterialInternalSvc service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var TLSMaterialInternalSvc_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "assets.ubika.io.v1beta.TLSMaterialInternalSvc",
	HandlerType: (*TLSMaterialInternalSvcServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Get",
			Handler:    _TLSMaterialInternalSvc_Get_Handler,
		},
		{
			MethodName: "List",
			Handler:    _TLSMaterialInternalSvc_List_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "Watch",
			Handler:       _TLSMaterialInternalSvc_Watch_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "lib/proto/assets.ubika.io/v1beta/asset_service.proto",
}

const (
	IPBlacklistSvc_List_FullMethodName   = "/assets.ubika.io.v1beta.IPBlacklistSvc/List"
	IPBlacklistSvc_Create_FullMethodName = "/assets.ubika.io.v1beta.IPBlacklistSvc/Create"
	IPBlacklistSvc_Get_FullMethodName    = "/assets.ubika.io.v1beta.IPBlacklistSvc/Get"
	IPBlacklistSvc_Update_FullMethodName = "/assets.ubika.io.v1beta.IPBlacklistSvc/Update"
	IPBlacklistSvc_Delete_FullMethodName = "/assets.ubika.io.v1beta.IPBlacklistSvc/Delete"
	IPBlacklistSvc_Watch_FullMethodName  = "/assets.ubika.io.v1beta.IPBlacklistSvc/Watch"
)

// IPBlacklistSvcClient is the client API for IPBlacklistSvc service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type IPBlacklistSvcClient interface {
	List(ctx context.Context, in *v1beta.ListOptions, opts ...grpc.CallOption) (*IPBlacklistList, error)
	Create(ctx context.Context, in *IPBlacklist, opts ...grpc.CallOption) (*IPBlacklist, error)
	Get(ctx context.Context, in *v1beta.GetOptions, opts ...grpc.CallOption) (*IPBlacklist, error)
	Update(ctx context.Context, in *IPBlacklist, opts ...grpc.CallOption) (*IPBlacklist, error)
	Delete(ctx context.Context, in *v1beta.DeleteOptions, opts ...grpc.CallOption) (*IPBlacklist, error)
	Watch(ctx context.Context, in *v1beta.WatchOptions, opts ...grpc.CallOption) (IPBlacklistSvc_WatchClient, error)
}

type iPBlacklistSvcClient struct {
	cc grpc.ClientConnInterface
}

func NewIPBlacklistSvcClient(cc grpc.ClientConnInterface) IPBlacklistSvcClient {
	return &iPBlacklistSvcClient{cc}
}

func (c *iPBlacklistSvcClient) List(ctx context.Context, in *v1beta.ListOptions, opts ...grpc.CallOption) (*IPBlacklistList, error) {
	out := new(IPBlacklistList)
	err := c.cc.Invoke(ctx, IPBlacklistSvc_List_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *iPBlacklistSvcClient) Create(ctx context.Context, in *IPBlacklist, opts ...grpc.CallOption) (*IPBlacklist, error) {
	out := new(IPBlacklist)
	err := c.cc.Invoke(ctx, IPBlacklistSvc_Create_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *iPBlacklistSvcClient) Get(ctx context.Context, in *v1beta.GetOptions, opts ...grpc.CallOption) (*IPBlacklist, error) {
	out := new(IPBlacklist)
	err := c.cc.Invoke(ctx, IPBlacklistSvc_Get_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *iPBlacklistSvcClient) Update(ctx context.Context, in *IPBlacklist, opts ...grpc.CallOption) (*IPBlacklist, error) {
	out := new(IPBlacklist)
	err := c.cc.Invoke(ctx, IPBlacklistSvc_Update_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *iPBlacklistSvcClient) Delete(ctx context.Context, in *v1beta.DeleteOptions, opts ...grpc.CallOption) (*IPBlacklist, error) {
	out := new(IPBlacklist)
	err := c.cc.Invoke(ctx, IPBlacklistSvc_Delete_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *iPBlacklistSvcClient) Watch(ctx context.Context, in *v1beta.WatchOptions, opts ...grpc.CallOption) (IPBlacklistSvc_WatchClient, error) {
	stream, err := c.cc.NewStream(ctx, &IPBlacklistSvc_ServiceDesc.Streams[0], IPBlacklistSvc_Watch_FullMethodName, opts...)
	if err != nil {
		return nil, err
	}
	x := &iPBlacklistSvcWatchClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type IPBlacklistSvc_WatchClient interface {
	Recv() (*v1beta.WatchEvent, error)
	grpc.ClientStream
}

type iPBlacklistSvcWatchClient struct {
	grpc.ClientStream
}

func (x *iPBlacklistSvcWatchClient) Recv() (*v1beta.WatchEvent, error) {
	m := new(v1beta.WatchEvent)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

// IPBlacklistSvcServer is the server API for IPBlacklistSvc service.
// All implementations must embed UnimplementedIPBlacklistSvcServer
// for forward compatibility
type IPBlacklistSvcServer interface {
	List(context.Context, *v1beta.ListOptions) (*IPBlacklistList, error)
	Create(context.Context, *IPBlacklist) (*IPBlacklist, error)
	Get(context.Context, *v1beta.GetOptions) (*IPBlacklist, error)
	Update(context.Context, *IPBlacklist) (*IPBlacklist, error)
	Delete(context.Context, *v1beta.DeleteOptions) (*IPBlacklist, error)
	Watch(*v1beta.WatchOptions, IPBlacklistSvc_WatchServer) error
	mustEmbedUnimplementedIPBlacklistSvcServer()
}

// UnimplementedIPBlacklistSvcServer must be embedded to have forward compatible implementations.
type UnimplementedIPBlacklistSvcServer struct {
}

func (UnimplementedIPBlacklistSvcServer) List(context.Context, *v1beta.ListOptions) (*IPBlacklistList, error) {
	return nil, status.Errorf(codes.Unimplemented, "method List not implemented")
}
func (UnimplementedIPBlacklistSvcServer) Create(context.Context, *IPBlacklist) (*IPBlacklist, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Create not implemented")
}
func (UnimplementedIPBlacklistSvcServer) Get(context.Context, *v1beta.GetOptions) (*IPBlacklist, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Get not implemented")
}
func (UnimplementedIPBlacklistSvcServer) Update(context.Context, *IPBlacklist) (*IPBlacklist, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Update not implemented")
}
func (UnimplementedIPBlacklistSvcServer) Delete(context.Context, *v1beta.DeleteOptions) (*IPBlacklist, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Delete not implemented")
}
func (UnimplementedIPBlacklistSvcServer) Watch(*v1beta.WatchOptions, IPBlacklistSvc_WatchServer) error {
	return status.Errorf(codes.Unimplemented, "method Watch not implemented")
}
func (UnimplementedIPBlacklistSvcServer) mustEmbedUnimplementedIPBlacklistSvcServer() {}

// UnsafeIPBlacklistSvcServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to IPBlacklistSvcServer will
// result in compilation errors.
type UnsafeIPBlacklistSvcServer interface {
	mustEmbedUnimplementedIPBlacklistSvcServer()
}

func RegisterIPBlacklistSvcServer(s grpc.ServiceRegistrar, srv IPBlacklistSvcServer) {
	s.RegisterService(&IPBlacklistSvc_ServiceDesc, srv)
}

func _IPBlacklistSvc_List_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(v1beta.ListOptions)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(IPBlacklistSvcServer).List(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: IPBlacklistSvc_List_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(IPBlacklistSvcServer).List(ctx, req.(*v1beta.ListOptions))
	}
	return interceptor(ctx, in, info, handler)
}

func _IPBlacklistSvc_Create_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(IPBlacklist)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(IPBlacklistSvcServer).Create(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: IPBlacklistSvc_Create_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(IPBlacklistSvcServer).Create(ctx, req.(*IPBlacklist))
	}
	return interceptor(ctx, in, info, handler)
}

func _IPBlacklistSvc_Get_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(v1beta.GetOptions)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(IPBlacklistSvcServer).Get(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: IPBlacklistSvc_Get_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(IPBlacklistSvcServer).Get(ctx, req.(*v1beta.GetOptions))
	}
	return interceptor(ctx, in, info, handler)
}

func _IPBlacklistSvc_Update_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(IPBlacklist)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(IPBlacklistSvcServer).Update(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: IPBlacklistSvc_Update_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(IPBlacklistSvcServer).Update(ctx, req.(*IPBlacklist))
	}
	return interceptor(ctx, in, info, handler)
}

func _IPBlacklistSvc_Delete_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(v1beta.DeleteOptions)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(IPBlacklistSvcServer).Delete(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: IPBlacklistSvc_Delete_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(IPBlacklistSvcServer).Delete(ctx, req.(*v1beta.DeleteOptions))
	}
	return interceptor(ctx, in, info, handler)
}

func _IPBlacklistSvc_Watch_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(v1beta.WatchOptions)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(IPBlacklistSvcServer).Watch(m, &iPBlacklistSvcWatchServer{stream})
}

type IPBlacklistSvc_WatchServer interface {
	Send(*v1beta.WatchEvent) error
	grpc.ServerStream
}

type iPBlacklistSvcWatchServer struct {
	grpc.ServerStream
}

func (x *iPBlacklistSvcWatchServer) Send(m *v1beta.WatchEvent) error {
	return x.ServerStream.SendMsg(m)
}

// IPBlacklistSvc_ServiceDesc is the grpc.ServiceDesc for IPBlacklistSvc service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var IPBlacklistSvc_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "assets.ubika.io.v1beta.IPBlacklistSvc",
	HandlerType: (*IPBlacklistSvcServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "List",
			Handler:    _IPBlacklistSvc_List_Handler,
		},
		{
			MethodName: "Create",
			Handler:    _IPBlacklistSvc_Create_Handler,
		},
		{
			MethodName: "Get",
			Handler:    _IPBlacklistSvc_Get_Handler,
		},
		{
			MethodName: "Update",
			Handler:    _IPBlacklistSvc_Update_Handler,
		},
		{
			MethodName: "Delete",
			Handler:    _IPBlacklistSvc_Delete_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "Watch",
			Handler:       _IPBlacklistSvc_Watch_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "lib/proto/assets.ubika.io/v1beta/asset_service.proto",
}
