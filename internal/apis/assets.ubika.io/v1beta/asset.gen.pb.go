// Code generated by protoc-gen-api-client. DO NOT EDIT.
package v1beta

import (
	fmt "fmt"
	runtime "github.com/ubikasec/terraform-provider-ubika/internal/api/runtime"
	v1beta "github.com/ubikasec/terraform-provider-ubika/internal/apis/meta/v1beta"
	proto "google.golang.org/protobuf/proto"
	timestamppb "google.golang.org/protobuf/types/known/timestamppb"
	strings "strings"
)

const kindSecurityMode = "SecurityMode"
const kindExceptionProfile = "ExceptionProfile"
const kindExceptionProfileList = "ExceptionProfileList"
const kindAPIModule = "APIModule"
const kindApplicationModule = "ApplicationModule"
const kindWorkflow = "Workflow"
const kindWorkflowList = "WorkflowList"
const kindCustomWkfModule = "CustomWkfModule"
const kindWebSocketSecurityMode = "WebSocketSecurityMode"
const kindWebSocketModule = "WebSocketModule"
const kindIPReputationThreat = "IPReputationThreat"
const kindIPReputationModule = "IPReputationModule"
const kindGeoIPMode = "GeoIPMode"
const kindGeoIPModule = "GeoIPModule"
const kindIPBlacklistModule = "IPBlacklistModule"
const kindBackendState = "BackendState"
const kindDeploymentType = "DeploymentType"
const kindBackendCertificateCheck = "BackendCertificateCheck"
const kindDnsState = "DnsState"
const kindAssetState = "AssetState"
const kindRunningState = "RunningState"
const kindTLSMode = "TLSMode"
const kindAssetTlsState = "AssetTlsState"
const kindAsset = "Asset"
const kindAssetList = "AssetList"
const kindOpenAPI = "OpenAPI"
const kindOpenAPIList = "OpenAPIList"
const kindErrorDocument = "ErrorDocument"
const kindErrorDocumentList = "ErrorDocumentList"
const kindCSRCreate = "CSRCreate"
const kindCSR = "CSR"
const kindCSRList = "CSRList"
const kindCSRFull = "CSRFull"
const kindCSRCertificate = "CSRCertificate"
const kindTLSMaterial = "TLSMaterial"
const kindTLSMaterialList = "TLSMaterialList"
const kindTLSMaterialFull = "TLSMaterialFull"
const kindTLSManualCreate = "TLSManualCreate"
const kindTLSMaterialFullList = "TLSMaterialFullList"
const kindTLSConfiguration = "TLSConfiguration"
const kindTLSConfigurationList = "TLSConfigurationList"
const kindTLSConfigurationDefault = "TLSConfigurationDefault"
const kindIPBlacklist = "IPBlacklist"
const kindIPBlacklistList = "IPBlacklistList"

func (e SecurityMode_Enum) MarshalText() (text []byte, err error) {
	s := e.String()
	if strings.HasPrefix(s, "SECURITY_MODE_ENUM_") {
		s = s[19:]
	}
	return []byte(s), nil
}

func (e *SecurityMode_Enum) UnmarshalText(text []byte) error {
	repr := string(text)
	val, ok := SecurityMode_Enum_value[repr]
	if !ok {
		if !strings.HasPrefix(repr, "SECURITY_MODE_ENUM_") {
			repr = "SECURITY_MODE_ENUM_" + repr
			val, ok = SecurityMode_Enum_value[repr]
		}
	}
	if !ok {
		return fmt.Errorf("unrecognized enum SecurityMode_Enum value %q", repr)
	}
	*e = SecurityMode_Enum(val)
	return nil
}

// Define object spec ExceptionProfileSpec

// NewExceptionProfileSpec creates a new ExceptionProfileSpec
func NewExceptionProfileSpec() *ExceptionProfileSpec {
	return &ExceptionProfileSpec{}
}

// Equal
func (o1 *ExceptionProfileSpec) Equal(o2 *ExceptionProfileSpec) bool {
	return proto.Equal(o1, o2)
}

// Define object ExceptionProfile

// GroupVersionKind returns GroupVersionKind of the object
func (obj *ExceptionProfile) GroupVersionKind() runtime.GroupVersionKind {
	return GroupVersion.WithKind("ExceptionProfile")
}

func (obj *ExceptionProfile) GetCollectionName() string { return obj.GetMetadata().GetCollectionName() }
func (obj *ExceptionProfile) GetCollectionType() string { return obj.GetMetadata().GetCollectionType() }
func (obj *ExceptionProfile) GetName() string           { return obj.GetMetadata().GetName() }
func (obj *ExceptionProfile) SetName(name string)       { obj.Metadata.Name = name }
func (obj *ExceptionProfile) GetCreated() *timestamppb.Timestamp {
	return obj.GetMetadata().GetCreated()
}
func (obj *ExceptionProfile) SetCreated(created *timestamppb.Timestamp) {
	obj.Metadata.Created = created
}
func (obj *ExceptionProfile) GetUpdated() *timestamppb.Timestamp {
	return obj.GetMetadata().GetUpdated()
}
func (obj *ExceptionProfile) SetUpdated(updated *timestamppb.Timestamp) {
	obj.Metadata.Updated = updated
}
func (obj *ExceptionProfile) GetVersion() int64        { return obj.GetMetadata().GetVersion() }
func (obj *ExceptionProfile) SetVersion(version int64) { obj.Metadata.Version = version }

// WithSpec adds the Spec to the object,
// returns the object
func (obj *ExceptionProfile) WithSpec(spec *ExceptionProfileSpec) *ExceptionProfile {
	obj.Spec = spec
	return obj
}

// Equal
func (o1 *ExceptionProfile) Equal(o2 *ExceptionProfile) bool {
	return proto.Equal(o1, o2)
}

// NewExceptionProfile creates a ExceptionProfile
func NewExceptionProfile(name string) *ExceptionProfile {
	return &ExceptionProfile{
		ApiVersion: GroupVersion.String(),
		Kind:       "ExceptionProfile",
		Metadata:   &v1beta.ObjectMeta{Name: name},
		Spec:       NewExceptionProfileSpec(),
	}
}

// Define object ExceptionProfileList

// GroupVersionKind returns GroupVersionKind of the object
func (obj *ExceptionProfileList) GroupVersionKind() runtime.GroupVersionKind {
	return GroupVersion.WithKind("ExceptionProfileList")
}

func (obj *ExceptionProfileList) ListItems() (items []runtime.NamedObject) {
	if obj == nil {
		return
	}
	for _, i := range obj.Items {
		items = append(items, i)
	}
	return
}

// NewExceptionProfileList creates a ExceptionProfileList
func NewExceptionProfileList() *ExceptionProfileList {
	return &ExceptionProfileList{
		ApiVersion: GroupVersion.String(),
		Kind:       "ExceptionProfileList",
		Metadata:   &v1beta.ListMeta{},
		Items:      make([]*ExceptionProfile, 0),
	}
}

// Define object Workflow

// GroupVersionKind returns GroupVersionKind of the object
func (obj *Workflow) GroupVersionKind() runtime.GroupVersionKind {
	return GroupVersion.WithKind("Workflow")
}

func (obj *Workflow) GetCollectionName() string                 { return obj.GetMetadata().GetCollectionName() }
func (obj *Workflow) GetCollectionType() string                 { return obj.GetMetadata().GetCollectionType() }
func (obj *Workflow) GetName() string                           { return obj.GetMetadata().GetName() }
func (obj *Workflow) SetName(name string)                       { obj.Metadata.Name = name }
func (obj *Workflow) GetCreated() *timestamppb.Timestamp        { return obj.GetMetadata().GetCreated() }
func (obj *Workflow) SetCreated(created *timestamppb.Timestamp) { obj.Metadata.Created = created }
func (obj *Workflow) GetUpdated() *timestamppb.Timestamp        { return obj.GetMetadata().GetUpdated() }
func (obj *Workflow) SetUpdated(updated *timestamppb.Timestamp) { obj.Metadata.Updated = updated }
func (obj *Workflow) GetVersion() int64                         { return obj.GetMetadata().GetVersion() }
func (obj *Workflow) SetVersion(version int64)                  { obj.Metadata.Version = version }

// WithSpec adds the Spec to the object,
// returns the object
func (obj *Workflow) WithSpec(spec *WorkflowSpec) *Workflow {
	obj.Spec = spec
	return obj
}

// Equal
func (o1 *Workflow) Equal(o2 *Workflow) bool {
	return proto.Equal(o1, o2)
}

// NewWorkflow creates a Workflow
func NewWorkflow(name string) *Workflow {
	return &Workflow{
		ApiVersion: GroupVersion.String(),
		Kind:       "Workflow",
		Metadata:   &v1beta.ObjectMeta{Name: name},
		Spec:       NewWorkflowSpec(),
	}
}

// Define object WorkflowList

// GroupVersionKind returns GroupVersionKind of the object
func (obj *WorkflowList) GroupVersionKind() runtime.GroupVersionKind {
	return GroupVersion.WithKind("WorkflowList")
}

func (obj *WorkflowList) ListItems() (items []runtime.NamedObject) {
	if obj == nil {
		return
	}
	for _, i := range obj.Items {
		items = append(items, i)
	}
	return
}

// NewWorkflowList creates a WorkflowList
func NewWorkflowList() *WorkflowList {
	return &WorkflowList{
		ApiVersion: GroupVersion.String(),
		Kind:       "WorkflowList",
		Metadata:   &v1beta.ListMeta{},
		Items:      make([]*Workflow, 0),
	}
}

// Define object spec WorkflowSpec

// NewWorkflowSpec creates a new WorkflowSpec
func NewWorkflowSpec() *WorkflowSpec {
	return &WorkflowSpec{}
}

// Equal
func (o1 *WorkflowSpec) Equal(o2 *WorkflowSpec) bool {
	return proto.Equal(o1, o2)
}
func (e WebSocketSecurityMode_Enum) MarshalText() (text []byte, err error) {
	s := e.String()
	if strings.HasPrefix(s, "WEB_SOCKET_SECURITY_MODE_ENUM_") {
		s = s[30:]
	}
	return []byte(s), nil
}

func (e *WebSocketSecurityMode_Enum) UnmarshalText(text []byte) error {
	repr := string(text)
	val, ok := WebSocketSecurityMode_Enum_value[repr]
	if !ok {
		if !strings.HasPrefix(repr, "WEB_SOCKET_SECURITY_MODE_ENUM_") {
			repr = "WEB_SOCKET_SECURITY_MODE_ENUM_" + repr
			val, ok = WebSocketSecurityMode_Enum_value[repr]
		}
	}
	if !ok {
		return fmt.Errorf("unrecognized enum WebSocketSecurityMode_Enum value %q", repr)
	}
	*e = WebSocketSecurityMode_Enum(val)
	return nil
}

func (e IPReputationThreat_Enum) MarshalText() (text []byte, err error) {
	s := e.String()
	if strings.HasPrefix(s, "IP_REPUTATION_THREAT_ENUM_") {
		s = s[26:]
	}
	return []byte(s), nil
}

func (e *IPReputationThreat_Enum) UnmarshalText(text []byte) error {
	repr := string(text)
	val, ok := IPReputationThreat_Enum_value[repr]
	if !ok {
		if !strings.HasPrefix(repr, "IP_REPUTATION_THREAT_ENUM_") {
			repr = "IP_REPUTATION_THREAT_ENUM_" + repr
			val, ok = IPReputationThreat_Enum_value[repr]
		}
	}
	if !ok {
		return fmt.Errorf("unrecognized enum IPReputationThreat_Enum value %q", repr)
	}
	*e = IPReputationThreat_Enum(val)
	return nil
}

func (e GeoIPMode_Enum) MarshalText() (text []byte, err error) {
	s := e.String()
	if strings.HasPrefix(s, "GEO_IP_MODE_ENUM_") {
		s = s[17:]
	}
	return []byte(s), nil
}

func (e *GeoIPMode_Enum) UnmarshalText(text []byte) error {
	repr := string(text)
	val, ok := GeoIPMode_Enum_value[repr]
	if !ok {
		if !strings.HasPrefix(repr, "GEO_IP_MODE_ENUM_") {
			repr = "GEO_IP_MODE_ENUM_" + repr
			val, ok = GeoIPMode_Enum_value[repr]
		}
	}
	if !ok {
		return fmt.Errorf("unrecognized enum GeoIPMode_Enum value %q", repr)
	}
	*e = GeoIPMode_Enum(val)
	return nil
}

// Define object spec AssetSpec

// NewAssetSpec creates a new AssetSpec
func NewAssetSpec() *AssetSpec {
	return &AssetSpec{}
}

// Equal
func (o1 *AssetSpec) Equal(o2 *AssetSpec) bool {
	return proto.Equal(o1, o2)
}
func (e BackendState_Enum) MarshalText() (text []byte, err error) {
	s := e.String()
	if strings.HasPrefix(s, "BACKEND_STATE_ENUM_") {
		s = s[19:]
	}
	return []byte(s), nil
}

func (e *BackendState_Enum) UnmarshalText(text []byte) error {
	repr := string(text)
	val, ok := BackendState_Enum_value[repr]
	if !ok {
		if !strings.HasPrefix(repr, "BACKEND_STATE_ENUM_") {
			repr = "BACKEND_STATE_ENUM_" + repr
			val, ok = BackendState_Enum_value[repr]
		}
	}
	if !ok {
		return fmt.Errorf("unrecognized enum BackendState_Enum value %q", repr)
	}
	*e = BackendState_Enum(val)
	return nil
}

func (e DeploymentType_Enum) MarshalText() (text []byte, err error) {
	s := e.String()
	if strings.HasPrefix(s, "DEPLOYMENT_TYPE_ENUM_") {
		s = s[21:]
	}
	return []byte(s), nil
}

func (e *DeploymentType_Enum) UnmarshalText(text []byte) error {
	repr := string(text)
	val, ok := DeploymentType_Enum_value[repr]
	if !ok {
		if !strings.HasPrefix(repr, "DEPLOYMENT_TYPE_ENUM_") {
			repr = "DEPLOYMENT_TYPE_ENUM_" + repr
			val, ok = DeploymentType_Enum_value[repr]
		}
	}
	if !ok {
		return fmt.Errorf("unrecognized enum DeploymentType_Enum value %q", repr)
	}
	*e = DeploymentType_Enum(val)
	return nil
}

func (e BackendCertificateCheck_Enum) MarshalText() (text []byte, err error) {
	s := e.String()
	if strings.HasPrefix(s, "BACKEND_CERTIFICATE_CHECK_ENUM_") {
		s = s[31:]
	}
	return []byte(s), nil
}

func (e *BackendCertificateCheck_Enum) UnmarshalText(text []byte) error {
	repr := string(text)
	val, ok := BackendCertificateCheck_Enum_value[repr]
	if !ok {
		if !strings.HasPrefix(repr, "BACKEND_CERTIFICATE_CHECK_ENUM_") {
			repr = "BACKEND_CERTIFICATE_CHECK_ENUM_" + repr
			val, ok = BackendCertificateCheck_Enum_value[repr]
		}
	}
	if !ok {
		return fmt.Errorf("unrecognized enum BackendCertificateCheck_Enum value %q", repr)
	}
	*e = BackendCertificateCheck_Enum(val)
	return nil
}

func (e DnsState_Enum) MarshalText() (text []byte, err error) {
	s := e.String()
	if strings.HasPrefix(s, "DNS_STATE_ENUM_") {
		s = s[15:]
	}
	return []byte(s), nil
}

func (e *DnsState_Enum) UnmarshalText(text []byte) error {
	repr := string(text)
	val, ok := DnsState_Enum_value[repr]
	if !ok {
		if !strings.HasPrefix(repr, "DNS_STATE_ENUM_") {
			repr = "DNS_STATE_ENUM_" + repr
			val, ok = DnsState_Enum_value[repr]
		}
	}
	if !ok {
		return fmt.Errorf("unrecognized enum DnsState_Enum value %q", repr)
	}
	*e = DnsState_Enum(val)
	return nil
}

func (e RunningState_Enum) MarshalText() (text []byte, err error) {
	s := e.String()
	if strings.HasPrefix(s, "RUNNING_STATE_ENUM_") {
		s = s[19:]
	}
	return []byte(s), nil
}

func (e *RunningState_Enum) UnmarshalText(text []byte) error {
	repr := string(text)
	val, ok := RunningState_Enum_value[repr]
	if !ok {
		if !strings.HasPrefix(repr, "RUNNING_STATE_ENUM_") {
			repr = "RUNNING_STATE_ENUM_" + repr
			val, ok = RunningState_Enum_value[repr]
		}
	}
	if !ok {
		return fmt.Errorf("unrecognized enum RunningState_Enum value %q", repr)
	}
	*e = RunningState_Enum(val)
	return nil
}

func (e TLSMode_Enum) MarshalText() (text []byte, err error) {
	s := e.String()
	if strings.HasPrefix(s, "TLS_MODE_ENUM_") {
		s = s[14:]
	}
	return []byte(s), nil
}

func (e *TLSMode_Enum) UnmarshalText(text []byte) error {
	repr := string(text)
	val, ok := TLSMode_Enum_value[repr]
	if !ok {
		if !strings.HasPrefix(repr, "TLS_MODE_ENUM_") {
			repr = "TLS_MODE_ENUM_" + repr
			val, ok = TLSMode_Enum_value[repr]
		}
	}
	if !ok {
		return fmt.Errorf("unrecognized enum TLSMode_Enum value %q", repr)
	}
	*e = TLSMode_Enum(val)
	return nil
}

// Define object status AssetStatus

// NewAssetStatus creates a new AssetStatus
func NewAssetStatus() *AssetStatus {
	return &AssetStatus{}
}

// Define object Asset

// GroupVersionKind returns GroupVersionKind of the object
func (obj *Asset) GroupVersionKind() runtime.GroupVersionKind {
	return GroupVersion.WithKind("Asset")
}

func (obj *Asset) GetCollectionName() string                 { return obj.GetMetadata().GetCollectionName() }
func (obj *Asset) GetCollectionType() string                 { return obj.GetMetadata().GetCollectionType() }
func (obj *Asset) GetName() string                           { return obj.GetMetadata().GetName() }
func (obj *Asset) SetName(name string)                       { obj.Metadata.Name = name }
func (obj *Asset) GetCreated() *timestamppb.Timestamp        { return obj.GetMetadata().GetCreated() }
func (obj *Asset) SetCreated(created *timestamppb.Timestamp) { obj.Metadata.Created = created }
func (obj *Asset) GetUpdated() *timestamppb.Timestamp        { return obj.GetMetadata().GetUpdated() }
func (obj *Asset) SetUpdated(updated *timestamppb.Timestamp) { obj.Metadata.Updated = updated }
func (obj *Asset) GetVersion() int64                         { return obj.GetMetadata().GetVersion() }
func (obj *Asset) SetVersion(version int64)                  { obj.Metadata.Version = version }

// WithSpec adds the Spec to the object,
// returns the object
func (obj *Asset) WithSpec(spec *AssetSpec) *Asset {
	obj.Spec = spec
	return obj
}

// Equal
func (o1 *Asset) Equal(o2 *Asset) bool {
	return proto.Equal(o1, o2)
}

// NewAsset creates a Asset
func NewAsset(name string) *Asset {
	return &Asset{
		ApiVersion: GroupVersion.String(),
		Kind:       "Asset",
		Metadata:   &v1beta.ObjectMeta{Name: name},
		Spec:       NewAssetSpec(),
	}
}

// Define object AssetList

// GroupVersionKind returns GroupVersionKind of the object
func (obj *AssetList) GroupVersionKind() runtime.GroupVersionKind {
	return GroupVersion.WithKind("AssetList")
}

func (obj *AssetList) ListItems() (items []runtime.NamedObject) {
	if obj == nil {
		return
	}
	for _, i := range obj.Items {
		items = append(items, i)
	}
	return
}

// NewAssetList creates a AssetList
func NewAssetList() *AssetList {
	return &AssetList{
		ApiVersion: GroupVersion.String(),
		Kind:       "AssetList",
		Metadata:   &v1beta.ListMeta{},
		Items:      make([]*Asset, 0),
	}
}

// Define object spec OpenAPISpec

// NewOpenAPISpec creates a new OpenAPISpec
func NewOpenAPISpec() *OpenAPISpec {
	return &OpenAPISpec{}
}

// Equal
func (o1 *OpenAPISpec) Equal(o2 *OpenAPISpec) bool {
	return proto.Equal(o1, o2)
}

// Define object OpenAPI

// GroupVersionKind returns GroupVersionKind of the object
func (obj *OpenAPI) GroupVersionKind() runtime.GroupVersionKind {
	return GroupVersion.WithKind("OpenAPI")
}

func (obj *OpenAPI) GetCollectionName() string                 { return obj.GetMetadata().GetCollectionName() }
func (obj *OpenAPI) GetCollectionType() string                 { return obj.GetMetadata().GetCollectionType() }
func (obj *OpenAPI) GetName() string                           { return obj.GetMetadata().GetName() }
func (obj *OpenAPI) SetName(name string)                       { obj.Metadata.Name = name }
func (obj *OpenAPI) GetCreated() *timestamppb.Timestamp        { return obj.GetMetadata().GetCreated() }
func (obj *OpenAPI) SetCreated(created *timestamppb.Timestamp) { obj.Metadata.Created = created }
func (obj *OpenAPI) GetUpdated() *timestamppb.Timestamp        { return obj.GetMetadata().GetUpdated() }
func (obj *OpenAPI) SetUpdated(updated *timestamppb.Timestamp) { obj.Metadata.Updated = updated }
func (obj *OpenAPI) GetVersion() int64                         { return obj.GetMetadata().GetVersion() }
func (obj *OpenAPI) SetVersion(version int64)                  { obj.Metadata.Version = version }

// WithSpec adds the Spec to the object,
// returns the object
func (obj *OpenAPI) WithSpec(spec *OpenAPISpec) *OpenAPI {
	obj.Spec = spec
	return obj
}

// Equal
func (o1 *OpenAPI) Equal(o2 *OpenAPI) bool {
	return proto.Equal(o1, o2)
}

// NewOpenAPI creates a OpenAPI
func NewOpenAPI(name string) *OpenAPI {
	return &OpenAPI{
		ApiVersion: GroupVersion.String(),
		Kind:       "OpenAPI",
		Metadata:   &v1beta.ObjectMeta{Name: name},
		Spec:       NewOpenAPISpec(),
	}
}

// Define object OpenAPIList

// GroupVersionKind returns GroupVersionKind of the object
func (obj *OpenAPIList) GroupVersionKind() runtime.GroupVersionKind {
	return GroupVersion.WithKind("OpenAPIList")
}

func (obj *OpenAPIList) ListItems() (items []runtime.NamedObject) {
	if obj == nil {
		return
	}
	for _, i := range obj.Items {
		items = append(items, i)
	}
	return
}

// NewOpenAPIList creates a OpenAPIList
func NewOpenAPIList() *OpenAPIList {
	return &OpenAPIList{
		ApiVersion: GroupVersion.String(),
		Kind:       "OpenAPIList",
		Metadata:   &v1beta.ListMeta{},
		Items:      make([]*OpenAPI, 0),
	}
}

// Define object ErrorDocument

// GroupVersionKind returns GroupVersionKind of the object
func (obj *ErrorDocument) GroupVersionKind() runtime.GroupVersionKind {
	return GroupVersion.WithKind("ErrorDocument")
}

func (obj *ErrorDocument) GetCollectionName() string                 { return obj.GetMetadata().GetCollectionName() }
func (obj *ErrorDocument) GetCollectionType() string                 { return obj.GetMetadata().GetCollectionType() }
func (obj *ErrorDocument) GetName() string                           { return obj.GetMetadata().GetName() }
func (obj *ErrorDocument) SetName(name string)                       { obj.Metadata.Name = name }
func (obj *ErrorDocument) GetCreated() *timestamppb.Timestamp        { return obj.GetMetadata().GetCreated() }
func (obj *ErrorDocument) SetCreated(created *timestamppb.Timestamp) { obj.Metadata.Created = created }
func (obj *ErrorDocument) GetUpdated() *timestamppb.Timestamp        { return obj.GetMetadata().GetUpdated() }
func (obj *ErrorDocument) SetUpdated(updated *timestamppb.Timestamp) { obj.Metadata.Updated = updated }
func (obj *ErrorDocument) GetVersion() int64                         { return obj.GetMetadata().GetVersion() }
func (obj *ErrorDocument) SetVersion(version int64)                  { obj.Metadata.Version = version }

// WithSpec adds the Spec to the object,
// returns the object
func (obj *ErrorDocument) WithSpec(spec *ErrorDocumentSpec) *ErrorDocument {
	obj.Spec = spec
	return obj
}

// Equal
func (o1 *ErrorDocument) Equal(o2 *ErrorDocument) bool {
	return proto.Equal(o1, o2)
}

// NewErrorDocument creates a ErrorDocument
func NewErrorDocument(name string) *ErrorDocument {
	return &ErrorDocument{
		ApiVersion: GroupVersion.String(),
		Kind:       "ErrorDocument",
		Metadata:   &v1beta.ObjectMeta{Name: name},
		Spec:       NewErrorDocumentSpec(),
	}
}

// Define object spec ErrorDocumentSpec

// NewErrorDocumentSpec creates a new ErrorDocumentSpec
func NewErrorDocumentSpec() *ErrorDocumentSpec {
	return &ErrorDocumentSpec{}
}

// Equal
func (o1 *ErrorDocumentSpec) Equal(o2 *ErrorDocumentSpec) bool {
	return proto.Equal(o1, o2)
}

// Define object ErrorDocumentList

// GroupVersionKind returns GroupVersionKind of the object
func (obj *ErrorDocumentList) GroupVersionKind() runtime.GroupVersionKind {
	return GroupVersion.WithKind("ErrorDocumentList")
}

func (obj *ErrorDocumentList) ListItems() (items []runtime.NamedObject) {
	if obj == nil {
		return
	}
	for _, i := range obj.Items {
		items = append(items, i)
	}
	return
}

// NewErrorDocumentList creates a ErrorDocumentList
func NewErrorDocumentList() *ErrorDocumentList {
	return &ErrorDocumentList{
		ApiVersion: GroupVersion.String(),
		Kind:       "ErrorDocumentList",
		Metadata:   &v1beta.ListMeta{},
		Items:      make([]*ErrorDocument, 0),
	}
}

// Define object status CSRStatus

// NewCSRStatus creates a new CSRStatus
func NewCSRStatus() *CSRStatus {
	return &CSRStatus{}
}

// Define object spec CSRCreateSpec

// NewCSRCreateSpec creates a new CSRCreateSpec
func NewCSRCreateSpec() *CSRCreateSpec {
	return &CSRCreateSpec{}
}

// Equal
func (o1 *CSRCreateSpec) Equal(o2 *CSRCreateSpec) bool {
	return proto.Equal(o1, o2)
}

// Define object CSRCreate

// GroupVersionKind returns GroupVersionKind of the object
func (obj *CSRCreate) GroupVersionKind() runtime.GroupVersionKind {
	return GroupVersion.WithKind("CSRCreate")
}

func (obj *CSRCreate) GetCollectionName() string                 { return obj.GetMetadata().GetCollectionName() }
func (obj *CSRCreate) GetCollectionType() string                 { return obj.GetMetadata().GetCollectionType() }
func (obj *CSRCreate) GetName() string                           { return obj.GetMetadata().GetName() }
func (obj *CSRCreate) SetName(name string)                       { obj.Metadata.Name = name }
func (obj *CSRCreate) GetCreated() *timestamppb.Timestamp        { return obj.GetMetadata().GetCreated() }
func (obj *CSRCreate) SetCreated(created *timestamppb.Timestamp) { obj.Metadata.Created = created }
func (obj *CSRCreate) GetUpdated() *timestamppb.Timestamp        { return obj.GetMetadata().GetUpdated() }
func (obj *CSRCreate) SetUpdated(updated *timestamppb.Timestamp) { obj.Metadata.Updated = updated }
func (obj *CSRCreate) GetVersion() int64                         { return obj.GetMetadata().GetVersion() }
func (obj *CSRCreate) SetVersion(version int64)                  { obj.Metadata.Version = version }

// WithSpec adds the Spec to the object,
// returns the object
func (obj *CSRCreate) WithSpec(spec *CSRCreateSpec) *CSRCreate {
	obj.Spec = spec
	return obj
}

// Equal
func (o1 *CSRCreate) Equal(o2 *CSRCreate) bool {
	return proto.Equal(o1, o2)
}

// NewCSRCreate creates a CSRCreate
func NewCSRCreate(name string) *CSRCreate {
	return &CSRCreate{
		ApiVersion: GroupVersion.String(),
		Kind:       "CSRCreate",
		Metadata:   &v1beta.ObjectMeta{Name: name},
		Spec:       NewCSRCreateSpec(),
	}
}

// Define object spec CSRSpec

// NewCSRSpec creates a new CSRSpec
func NewCSRSpec() *CSRSpec {
	return &CSRSpec{}
}

// Equal
func (o1 *CSRSpec) Equal(o2 *CSRSpec) bool {
	return proto.Equal(o1, o2)
}

// Define object CSR

// GroupVersionKind returns GroupVersionKind of the object
func (obj *CSR) GroupVersionKind() runtime.GroupVersionKind {
	return GroupVersion.WithKind("CSR")
}

func (obj *CSR) GetCollectionName() string                 { return obj.GetMetadata().GetCollectionName() }
func (obj *CSR) GetCollectionType() string                 { return obj.GetMetadata().GetCollectionType() }
func (obj *CSR) GetName() string                           { return obj.GetMetadata().GetName() }
func (obj *CSR) SetName(name string)                       { obj.Metadata.Name = name }
func (obj *CSR) GetCreated() *timestamppb.Timestamp        { return obj.GetMetadata().GetCreated() }
func (obj *CSR) SetCreated(created *timestamppb.Timestamp) { obj.Metadata.Created = created }
func (obj *CSR) GetUpdated() *timestamppb.Timestamp        { return obj.GetMetadata().GetUpdated() }
func (obj *CSR) SetUpdated(updated *timestamppb.Timestamp) { obj.Metadata.Updated = updated }
func (obj *CSR) GetVersion() int64                         { return obj.GetMetadata().GetVersion() }
func (obj *CSR) SetVersion(version int64)                  { obj.Metadata.Version = version }

// WithSpec adds the Spec to the object,
// returns the object
func (obj *CSR) WithSpec(spec *CSRSpec) *CSR {
	obj.Spec = spec
	return obj
}

// Equal
func (o1 *CSR) Equal(o2 *CSR) bool {
	return proto.Equal(o1, o2)
}

// NewCSR creates a CSR
func NewCSR(name string) *CSR {
	return &CSR{
		ApiVersion: GroupVersion.String(),
		Kind:       "CSR",
		Metadata:   &v1beta.ObjectMeta{Name: name},
		Spec:       NewCSRSpec(),
	}
}

// Define object CSRList

// GroupVersionKind returns GroupVersionKind of the object
func (obj *CSRList) GroupVersionKind() runtime.GroupVersionKind {
	return GroupVersion.WithKind("CSRList")
}

func (obj *CSRList) ListItems() (items []runtime.NamedObject) {
	if obj == nil {
		return
	}
	for _, i := range obj.Items {
		items = append(items, i)
	}
	return
}

// NewCSRList creates a CSRList
func NewCSRList() *CSRList {
	return &CSRList{
		ApiVersion: GroupVersion.String(),
		Kind:       "CSRList",
		Metadata:   &v1beta.ListMeta{},
		Items:      make([]*CSR, 0),
	}
}

// Define object spec CSRFullSpec

// NewCSRFullSpec creates a new CSRFullSpec
func NewCSRFullSpec() *CSRFullSpec {
	return &CSRFullSpec{}
}

// Equal
func (o1 *CSRFullSpec) Equal(o2 *CSRFullSpec) bool {
	return proto.Equal(o1, o2)
}

// Define object CSRFull

// GroupVersionKind returns GroupVersionKind of the object
func (obj *CSRFull) GroupVersionKind() runtime.GroupVersionKind {
	return GroupVersion.WithKind("CSRFull")
}

func (obj *CSRFull) GetCollectionName() string                 { return obj.GetMetadata().GetCollectionName() }
func (obj *CSRFull) GetCollectionType() string                 { return obj.GetMetadata().GetCollectionType() }
func (obj *CSRFull) GetName() string                           { return obj.GetMetadata().GetName() }
func (obj *CSRFull) SetName(name string)                       { obj.Metadata.Name = name }
func (obj *CSRFull) GetCreated() *timestamppb.Timestamp        { return obj.GetMetadata().GetCreated() }
func (obj *CSRFull) SetCreated(created *timestamppb.Timestamp) { obj.Metadata.Created = created }
func (obj *CSRFull) GetUpdated() *timestamppb.Timestamp        { return obj.GetMetadata().GetUpdated() }
func (obj *CSRFull) SetUpdated(updated *timestamppb.Timestamp) { obj.Metadata.Updated = updated }
func (obj *CSRFull) GetVersion() int64                         { return obj.GetMetadata().GetVersion() }
func (obj *CSRFull) SetVersion(version int64)                  { obj.Metadata.Version = version }

// WithSpec adds the Spec to the object,
// returns the object
func (obj *CSRFull) WithSpec(spec *CSRFullSpec) *CSRFull {
	obj.Spec = spec
	return obj
}

// Equal
func (o1 *CSRFull) Equal(o2 *CSRFull) bool {
	return proto.Equal(o1, o2)
}

// NewCSRFull creates a CSRFull
func NewCSRFull(name string) *CSRFull {
	return &CSRFull{
		ApiVersion: GroupVersion.String(),
		Kind:       "CSRFull",
		Metadata:   &v1beta.ObjectMeta{Name: name},
		Spec:       NewCSRFullSpec(),
	}
}

// Define object spec CSRCertificateSpec

// NewCSRCertificateSpec creates a new CSRCertificateSpec
func NewCSRCertificateSpec() *CSRCertificateSpec {
	return &CSRCertificateSpec{}
}

// Equal
func (o1 *CSRCertificateSpec) Equal(o2 *CSRCertificateSpec) bool {
	return proto.Equal(o1, o2)
}

// Define object CSRCertificate

// GroupVersionKind returns GroupVersionKind of the object
func (obj *CSRCertificate) GroupVersionKind() runtime.GroupVersionKind {
	return GroupVersion.WithKind("CSRCertificate")
}

func (obj *CSRCertificate) GetCollectionName() string                 { return obj.GetMetadata().GetCollectionName() }
func (obj *CSRCertificate) GetCollectionType() string                 { return obj.GetMetadata().GetCollectionType() }
func (obj *CSRCertificate) GetName() string                           { return obj.GetMetadata().GetName() }
func (obj *CSRCertificate) SetName(name string)                       { obj.Metadata.Name = name }
func (obj *CSRCertificate) GetCreated() *timestamppb.Timestamp        { return obj.GetMetadata().GetCreated() }
func (obj *CSRCertificate) SetCreated(created *timestamppb.Timestamp) { obj.Metadata.Created = created }
func (obj *CSRCertificate) GetUpdated() *timestamppb.Timestamp        { return obj.GetMetadata().GetUpdated() }
func (obj *CSRCertificate) SetUpdated(updated *timestamppb.Timestamp) { obj.Metadata.Updated = updated }
func (obj *CSRCertificate) GetVersion() int64                         { return obj.GetMetadata().GetVersion() }
func (obj *CSRCertificate) SetVersion(version int64)                  { obj.Metadata.Version = version }

// WithSpec adds the Spec to the object,
// returns the object
func (obj *CSRCertificate) WithSpec(spec *CSRCertificateSpec) *CSRCertificate {
	obj.Spec = spec
	return obj
}

// Equal
func (o1 *CSRCertificate) Equal(o2 *CSRCertificate) bool {
	return proto.Equal(o1, o2)
}

// NewCSRCertificate creates a CSRCertificate
func NewCSRCertificate(name string) *CSRCertificate {
	return &CSRCertificate{
		ApiVersion: GroupVersion.String(),
		Kind:       "CSRCertificate",
		Metadata:   &v1beta.ObjectMeta{Name: name},
		Spec:       NewCSRCertificateSpec(),
	}
}

// Define object spec TLSMaterialSpec

// NewTLSMaterialSpec creates a new TLSMaterialSpec
func NewTLSMaterialSpec() *TLSMaterialSpec {
	return &TLSMaterialSpec{}
}

// Equal
func (o1 *TLSMaterialSpec) Equal(o2 *TLSMaterialSpec) bool {
	return proto.Equal(o1, o2)
}

// Define object TLSMaterial

// GroupVersionKind returns GroupVersionKind of the object
func (obj *TLSMaterial) GroupVersionKind() runtime.GroupVersionKind {
	return GroupVersion.WithKind("TLSMaterial")
}

func (obj *TLSMaterial) GetCollectionName() string                 { return obj.GetMetadata().GetCollectionName() }
func (obj *TLSMaterial) GetCollectionType() string                 { return obj.GetMetadata().GetCollectionType() }
func (obj *TLSMaterial) GetName() string                           { return obj.GetMetadata().GetName() }
func (obj *TLSMaterial) SetName(name string)                       { obj.Metadata.Name = name }
func (obj *TLSMaterial) GetCreated() *timestamppb.Timestamp        { return obj.GetMetadata().GetCreated() }
func (obj *TLSMaterial) SetCreated(created *timestamppb.Timestamp) { obj.Metadata.Created = created }
func (obj *TLSMaterial) GetUpdated() *timestamppb.Timestamp        { return obj.GetMetadata().GetUpdated() }
func (obj *TLSMaterial) SetUpdated(updated *timestamppb.Timestamp) { obj.Metadata.Updated = updated }
func (obj *TLSMaterial) GetVersion() int64                         { return obj.GetMetadata().GetVersion() }
func (obj *TLSMaterial) SetVersion(version int64)                  { obj.Metadata.Version = version }

// WithSpec adds the Spec to the object,
// returns the object
func (obj *TLSMaterial) WithSpec(spec *TLSMaterialSpec) *TLSMaterial {
	obj.Spec = spec
	return obj
}

// Equal
func (o1 *TLSMaterial) Equal(o2 *TLSMaterial) bool {
	return proto.Equal(o1, o2)
}

// NewTLSMaterial creates a TLSMaterial
func NewTLSMaterial(name string) *TLSMaterial {
	return &TLSMaterial{
		ApiVersion: GroupVersion.String(),
		Kind:       "TLSMaterial",
		Metadata:   &v1beta.ObjectMeta{Name: name},
		Spec:       NewTLSMaterialSpec(),
	}
}

// Define object TLSMaterialList

// GroupVersionKind returns GroupVersionKind of the object
func (obj *TLSMaterialList) GroupVersionKind() runtime.GroupVersionKind {
	return GroupVersion.WithKind("TLSMaterialList")
}

func (obj *TLSMaterialList) ListItems() (items []runtime.NamedObject) {
	if obj == nil {
		return
	}
	for _, i := range obj.Items {
		items = append(items, i)
	}
	return
}

// NewTLSMaterialList creates a TLSMaterialList
func NewTLSMaterialList() *TLSMaterialList {
	return &TLSMaterialList{
		ApiVersion: GroupVersion.String(),
		Kind:       "TLSMaterialList",
		Metadata:   &v1beta.ListMeta{},
		Items:      make([]*TLSMaterial, 0),
	}
}

// Define object status TLSMaterialStatus

// NewTLSMaterialStatus creates a new TLSMaterialStatus
func NewTLSMaterialStatus() *TLSMaterialStatus {
	return &TLSMaterialStatus{}
}

// Define object spec TLSMaterialFullSpec

// NewTLSMaterialFullSpec creates a new TLSMaterialFullSpec
func NewTLSMaterialFullSpec() *TLSMaterialFullSpec {
	return &TLSMaterialFullSpec{}
}

// Equal
func (o1 *TLSMaterialFullSpec) Equal(o2 *TLSMaterialFullSpec) bool {
	return proto.Equal(o1, o2)
}

// Define object TLSMaterialFull

// GroupVersionKind returns GroupVersionKind of the object
func (obj *TLSMaterialFull) GroupVersionKind() runtime.GroupVersionKind {
	return GroupVersion.WithKind("TLSMaterialFull")
}

func (obj *TLSMaterialFull) GetCollectionName() string { return obj.GetMetadata().GetCollectionName() }
func (obj *TLSMaterialFull) GetCollectionType() string { return obj.GetMetadata().GetCollectionType() }
func (obj *TLSMaterialFull) GetName() string           { return obj.GetMetadata().GetName() }
func (obj *TLSMaterialFull) SetName(name string)       { obj.Metadata.Name = name }
func (obj *TLSMaterialFull) GetCreated() *timestamppb.Timestamp {
	return obj.GetMetadata().GetCreated()
}
func (obj *TLSMaterialFull) SetCreated(created *timestamppb.Timestamp) {
	obj.Metadata.Created = created
}
func (obj *TLSMaterialFull) GetUpdated() *timestamppb.Timestamp {
	return obj.GetMetadata().GetUpdated()
}
func (obj *TLSMaterialFull) SetUpdated(updated *timestamppb.Timestamp) {
	obj.Metadata.Updated = updated
}
func (obj *TLSMaterialFull) GetVersion() int64        { return obj.GetMetadata().GetVersion() }
func (obj *TLSMaterialFull) SetVersion(version int64) { obj.Metadata.Version = version }

// WithSpec adds the Spec to the object,
// returns the object
func (obj *TLSMaterialFull) WithSpec(spec *TLSMaterialFullSpec) *TLSMaterialFull {
	obj.Spec = spec
	return obj
}

// Equal
func (o1 *TLSMaterialFull) Equal(o2 *TLSMaterialFull) bool {
	return proto.Equal(o1, o2)
}

// NewTLSMaterialFull creates a TLSMaterialFull
func NewTLSMaterialFull(name string) *TLSMaterialFull {
	return &TLSMaterialFull{
		ApiVersion: GroupVersion.String(),
		Kind:       "TLSMaterialFull",
		Metadata:   &v1beta.ObjectMeta{Name: name},
		Spec:       NewTLSMaterialFullSpec(),
	}
}

// Define object TLSManualCreate

// GroupVersionKind returns GroupVersionKind of the object
func (obj *TLSManualCreate) GroupVersionKind() runtime.GroupVersionKind {
	return GroupVersion.WithKind("TLSManualCreate")
}

func (obj *TLSManualCreate) GetCollectionName() string { return obj.GetMetadata().GetCollectionName() }
func (obj *TLSManualCreate) GetCollectionType() string { return obj.GetMetadata().GetCollectionType() }
func (obj *TLSManualCreate) GetName() string           { return obj.GetMetadata().GetName() }
func (obj *TLSManualCreate) SetName(name string)       { obj.Metadata.Name = name }
func (obj *TLSManualCreate) GetCreated() *timestamppb.Timestamp {
	return obj.GetMetadata().GetCreated()
}
func (obj *TLSManualCreate) SetCreated(created *timestamppb.Timestamp) {
	obj.Metadata.Created = created
}
func (obj *TLSManualCreate) GetUpdated() *timestamppb.Timestamp {
	return obj.GetMetadata().GetUpdated()
}
func (obj *TLSManualCreate) SetUpdated(updated *timestamppb.Timestamp) {
	obj.Metadata.Updated = updated
}
func (obj *TLSManualCreate) GetVersion() int64        { return obj.GetMetadata().GetVersion() }
func (obj *TLSManualCreate) SetVersion(version int64) { obj.Metadata.Version = version }

// WithSpec adds the Spec to the object,
// returns the object
func (obj *TLSManualCreate) WithSpec(spec *TLSManualCreateSpec) *TLSManualCreate {
	obj.Spec = spec
	return obj
}

// Equal
func (o1 *TLSManualCreate) Equal(o2 *TLSManualCreate) bool {
	return proto.Equal(o1, o2)
}

// NewTLSManualCreate creates a TLSManualCreate
func NewTLSManualCreate(name string) *TLSManualCreate {
	return &TLSManualCreate{
		ApiVersion: GroupVersion.String(),
		Kind:       "TLSManualCreate",
		Metadata:   &v1beta.ObjectMeta{Name: name},
		Spec:       NewTLSManualCreateSpec(),
	}
}

// Define object spec TLSManualCreateSpec

// NewTLSManualCreateSpec creates a new TLSManualCreateSpec
func NewTLSManualCreateSpec() *TLSManualCreateSpec {
	return &TLSManualCreateSpec{}
}

// Equal
func (o1 *TLSManualCreateSpec) Equal(o2 *TLSManualCreateSpec) bool {
	return proto.Equal(o1, o2)
}

// Define object TLSMaterialFullList

// GroupVersionKind returns GroupVersionKind of the object
func (obj *TLSMaterialFullList) GroupVersionKind() runtime.GroupVersionKind {
	return GroupVersion.WithKind("TLSMaterialFullList")
}

func (obj *TLSMaterialFullList) ListItems() (items []runtime.NamedObject) {
	if obj == nil {
		return
	}
	for _, i := range obj.Items {
		items = append(items, i)
	}
	return
}

// NewTLSMaterialFullList creates a TLSMaterialFullList
func NewTLSMaterialFullList() *TLSMaterialFullList {
	return &TLSMaterialFullList{
		ApiVersion: GroupVersion.String(),
		Kind:       "TLSMaterialFullList",
		Metadata:   &v1beta.ListMeta{},
		Items:      make([]*TLSMaterialFull, 0),
	}
}

// Define object spec TLSConfigurationSpec

// NewTLSConfigurationSpec creates a new TLSConfigurationSpec
func NewTLSConfigurationSpec() *TLSConfigurationSpec {
	return &TLSConfigurationSpec{}
}

// Equal
func (o1 *TLSConfigurationSpec) Equal(o2 *TLSConfigurationSpec) bool {
	return proto.Equal(o1, o2)
}

// Define object TLSConfiguration

// GroupVersionKind returns GroupVersionKind of the object
func (obj *TLSConfiguration) GroupVersionKind() runtime.GroupVersionKind {
	return GroupVersion.WithKind("TLSConfiguration")
}

func (obj *TLSConfiguration) GetCollectionName() string { return obj.GetMetadata().GetCollectionName() }
func (obj *TLSConfiguration) GetCollectionType() string { return obj.GetMetadata().GetCollectionType() }
func (obj *TLSConfiguration) GetName() string           { return obj.GetMetadata().GetName() }
func (obj *TLSConfiguration) SetName(name string)       { obj.Metadata.Name = name }
func (obj *TLSConfiguration) GetCreated() *timestamppb.Timestamp {
	return obj.GetMetadata().GetCreated()
}
func (obj *TLSConfiguration) SetCreated(created *timestamppb.Timestamp) {
	obj.Metadata.Created = created
}
func (obj *TLSConfiguration) GetUpdated() *timestamppb.Timestamp {
	return obj.GetMetadata().GetUpdated()
}
func (obj *TLSConfiguration) SetUpdated(updated *timestamppb.Timestamp) {
	obj.Metadata.Updated = updated
}
func (obj *TLSConfiguration) GetVersion() int64        { return obj.GetMetadata().GetVersion() }
func (obj *TLSConfiguration) SetVersion(version int64) { obj.Metadata.Version = version }

// WithSpec adds the Spec to the object,
// returns the object
func (obj *TLSConfiguration) WithSpec(spec *TLSConfigurationSpec) *TLSConfiguration {
	obj.Spec = spec
	return obj
}

// Equal
func (o1 *TLSConfiguration) Equal(o2 *TLSConfiguration) bool {
	return proto.Equal(o1, o2)
}

// NewTLSConfiguration creates a TLSConfiguration
func NewTLSConfiguration(name string) *TLSConfiguration {
	return &TLSConfiguration{
		ApiVersion: GroupVersion.String(),
		Kind:       "TLSConfiguration",
		Metadata:   &v1beta.ObjectMeta{Name: name},
		Spec:       NewTLSConfigurationSpec(),
	}
}

// Define object TLSConfigurationList

// GroupVersionKind returns GroupVersionKind of the object
func (obj *TLSConfigurationList) GroupVersionKind() runtime.GroupVersionKind {
	return GroupVersion.WithKind("TLSConfigurationList")
}

func (obj *TLSConfigurationList) ListItems() (items []runtime.NamedObject) {
	if obj == nil {
		return
	}
	for _, i := range obj.Items {
		items = append(items, i)
	}
	return
}

// NewTLSConfigurationList creates a TLSConfigurationList
func NewTLSConfigurationList() *TLSConfigurationList {
	return &TLSConfigurationList{
		ApiVersion: GroupVersion.String(),
		Kind:       "TLSConfigurationList",
		Metadata:   &v1beta.ListMeta{},
		Items:      make([]*TLSConfiguration, 0),
	}
}

// Define object spec IPBlacklistSpec

// NewIPBlacklistSpec creates a new IPBlacklistSpec
func NewIPBlacklistSpec() *IPBlacklistSpec {
	return &IPBlacklistSpec{}
}

// Equal
func (o1 *IPBlacklistSpec) Equal(o2 *IPBlacklistSpec) bool {
	return proto.Equal(o1, o2)
}

// Define object IPBlacklist

// GroupVersionKind returns GroupVersionKind of the object
func (obj *IPBlacklist) GroupVersionKind() runtime.GroupVersionKind {
	return GroupVersion.WithKind("IPBlacklist")
}

func (obj *IPBlacklist) GetCollectionName() string                 { return obj.GetMetadata().GetCollectionName() }
func (obj *IPBlacklist) GetCollectionType() string                 { return obj.GetMetadata().GetCollectionType() }
func (obj *IPBlacklist) GetName() string                           { return obj.GetMetadata().GetName() }
func (obj *IPBlacklist) SetName(name string)                       { obj.Metadata.Name = name }
func (obj *IPBlacklist) GetCreated() *timestamppb.Timestamp        { return obj.GetMetadata().GetCreated() }
func (obj *IPBlacklist) SetCreated(created *timestamppb.Timestamp) { obj.Metadata.Created = created }
func (obj *IPBlacklist) GetUpdated() *timestamppb.Timestamp        { return obj.GetMetadata().GetUpdated() }
func (obj *IPBlacklist) SetUpdated(updated *timestamppb.Timestamp) { obj.Metadata.Updated = updated }
func (obj *IPBlacklist) GetVersion() int64                         { return obj.GetMetadata().GetVersion() }
func (obj *IPBlacklist) SetVersion(version int64)                  { obj.Metadata.Version = version }

// WithSpec adds the Spec to the object,
// returns the object
func (obj *IPBlacklist) WithSpec(spec *IPBlacklistSpec) *IPBlacklist {
	obj.Spec = spec
	return obj
}

// Equal
func (o1 *IPBlacklist) Equal(o2 *IPBlacklist) bool {
	return proto.Equal(o1, o2)
}

// NewIPBlacklist creates a IPBlacklist
func NewIPBlacklist(name string) *IPBlacklist {
	return &IPBlacklist{
		ApiVersion: GroupVersion.String(),
		Kind:       "IPBlacklist",
		Metadata:   &v1beta.ObjectMeta{Name: name},
		Spec:       NewIPBlacklistSpec(),
	}
}

// Define object IPBlacklistList

// GroupVersionKind returns GroupVersionKind of the object
func (obj *IPBlacklistList) GroupVersionKind() runtime.GroupVersionKind {
	return GroupVersion.WithKind("IPBlacklistList")
}

func (obj *IPBlacklistList) ListItems() (items []runtime.NamedObject) {
	if obj == nil {
		return
	}
	for _, i := range obj.Items {
		items = append(items, i)
	}
	return
}

// NewIPBlacklistList creates a IPBlacklistList
func NewIPBlacklistList() *IPBlacklistList {
	return &IPBlacklistList{
		ApiVersion: GroupVersion.String(),
		Kind:       "IPBlacklistList",
		Metadata:   &v1beta.ListMeta{},
		Items:      make([]*IPBlacklist, 0),
	}
}
